// Class: ReadBDT
// Automatically generated by MethodBase::MakeClass
//

/* configuration options =====================================================

#GEN -*-*-*-*-*-*-*-*-*-*-*- general info -*-*-*-*-*-*-*-*-*-*-*-

Method         : BDT::BDT
TMVA Release   : 4.2.1         [262657]
ROOT Release   : 6.06/01       [394753]
Creator        : matthies
Date           : Tue Aug 28 16:51:09 2018
Host           : Linux vocms0301.cern.ch 2.6.32-642.4.2.el6.x86_64 #1 SMP Wed Aug 24 09:19:54 CEST 2016 x86_64 x86_64 x86_64 GNU/Linux
Dir            : /nfs/dust/cms/user/matthies/Analysis_80x_v5/CMSSW_8_0_24_patch1/src/UHH2/BoostedSingleTop/tmva_comb
Training events: 831976
Analysis type  : [Classification]


#OPT -*-*-*-*-*-*-*-*-*-*-*-*- options -*-*-*-*-*-*-*-*-*-*-*-*-

# Set by User:
V: "False" [Verbose output (short form of "VerbosityLevel" below - overrides the latter one)]
H: "False" [Print method-specific help message]
NTrees: "100" [Number of trees in the forest]
MaxDepth: "3" [Max depth of the decision tree allowed]
MinNodeSize: "2.5%" [Minimum percentage of training events required in a leaf node (default: Classification: 5%, Regression: 0.2%)]
nCuts: "20" [Number of grid points in variable range used in finding optimal cut in node splitting]
BoostType: "AdaBoost" [Boosting type for the trees in the forest (note: AdaCost is still experimental)]
UseBaggedBoost: "True" [Use only a random subsample of all events for growing the trees in each boost iteration.]
AdaBoostBeta: "5.000000e-01" [Learning rate  for AdaBoost algorithm]
BaggedSampleFraction: "5.000000e-01" [Relative size of bagged event sample to original size of the data sample (used whenever bagging is used (i.e. UseBaggedBoost, Bagging,)]
SeparationType: "giniindex" [Separation criterion for node splitting]
# Default:
VerbosityLevel: "Default" [Verbosity level]
VarTransform: "None" [List of variable transformations performed before training, e.g., "D_Background,P_Signal,G,N_AllClasses" for: "Decorrelation, PCA-transformation, Gaussianisation, Normalisation, each for the given class of events ('AllClasses' denotes all events of all classes, if no class indication is given, 'All' is assumed)"]
CreateMVAPdfs: "False" [Create PDFs for classifier outputs (signal and background)]
IgnoreNegWeightsInTraining: "False" [Events with negative weights are ignored in the training (but are included for testing and performance evaluation)]
AdaBoostR2Loss: "quadratic" [Type of Loss function in AdaBoostR2]
Shrinkage: "1.000000e+00" [Learning rate for GradBoost algorithm]
UseRandomisedTrees: "False" [Determine at each node splitting the cut variable only as the best out of a random subset of variables (like in RandomForests)]
UseNvars: "3" [Size of the subset of variables used with RandomisedTree option]
UsePoissonNvars: "True" [Interpret "UseNvars" not as fixed number but as mean of a Possion distribution in each split with RandomisedTree option]
UseYesNoLeaf: "True" [Use Sig or Bkg categories, or the purity=S/(S+B) as classification of the leaf node -> Real-AdaBoost]
NegWeightTreatment: "inverseboostnegweights" [How to treat events with negative weights in the BDT training (particular the boosting) : IgnoreInTraining;  Boost With inverse boostweight; Pair events with negative and positive weights in traning sample and *annihilate* them (experimental!)]
Css: "1.000000e+00" [AdaCost: cost of true signal selected signal]
Cts_sb: "1.000000e+00" [AdaCost: cost of true signal selected bkg]
Ctb_ss: "1.000000e+00" [AdaCost: cost of true bkg    selected signal]
Cbb: "1.000000e+00" [AdaCost: cost of true bkg    selected bkg ]
NodePurityLimit: "5.000000e-01" [In boosting/pruning, nodes with purity > NodePurityLimit are signal; background otherwise.]
DoBoostMonitor: "False" [Create control plot with ROC integral vs tree number]
UseFisherCuts: "False" [Use multivariate splits using the Fisher criterion]
MinLinCorrForFisher: "8.000000e-01" [The minimum linear correlation between two variables demanded for use in Fisher criterion in node splitting]
UseExclusiveVars: "False" [Variables already used in fisher criterion are not anymore analysed individually for node splitting]
DoPreselection: "False" [and and apply automatic pre-selection for 100% efficient signal (bkg) cuts prior to training]
SigToBkgFraction: "1.000000e+00" [Sig to Bkg ratio used in Training (similar to NodePurityLimit, which cannot be used in real adaboost]
PruneMethod: "nopruning" [Note: for BDTs use small trees (e.g.MaxDepth=3) and NoPruning:  Pruning: Method used for pruning (removal) of statistically insignificant branches ]
PruneStrength: "0.000000e+00" [Pruning strength]
PruningValFraction: "5.000000e-01" [Fraction of events to use for optimizing automatic pruning.]
nEventsMin: "0" [deprecated: Use MinNodeSize (in % of training events) instead]
UseBaggedGrad: "False" [deprecated: Use *UseBaggedBoost* instead:  Use only a random subsample of all events for growing the trees in each iteration.]
GradBaggingFraction: "5.000000e-01" [deprecated: Use *BaggedSampleFraction* instead: Defines the fraction of events to be used in each iteration, e.g. when UseBaggedGrad=kTRUE. ]
UseNTrainEvents: "0" [deprecated: Use *BaggedSampleFraction* instead: Number of randomly picked training events used in randomised (and bagged) trees]
NNodesMax: "0" [deprecated: Use MaxDepth instead to limit the tree size]
##


#VAR -*-*-*-*-*-*-*-*-*-*-*-* variables *-*-*-*-*-*-*-*-*-*-*-*-

NVar 9
tmva_n_btags                  tmva_n_btags                  tmva_n_btags                  N of b-tags                                                     'I'    [1,6]
tmva_deltaphi_bottomlepton    tmva_deltaphi_bottomlepton    tmva_deltaphi_bottomlepton    #Delta#phi(l,b)               rad                               'F'    [1.49556435645e-05,3.14159154892]
tmva_deltaphi_bottomtoptag    tmva_deltaphi_bottomtoptag    tmva_deltaphi_bottomtoptag    #Delta#phi(t,b)               rad                               'F'    [1.28149986267e-06,3.14158964157]
tmva_pseudotop_mass           tmva_pseudotop_mass           tmva_pseudotop_mass           l#nub mass                    GeV                               'F'    [86.5726852417,6195.93115234]
tmva_ptbalance                tmva_ptbalance                tmva_ptbalance                pT balance                                                      'F'    [-0.99961078167,4.41339540482]
tmva_wass_pt                  tmva_wass_pt                  tmva_wass_pt                  asso. W pT                    GeV                               'F'    [0.13556560874,2274.22290039]
tmva_lepton_pt                tmva_lepton_pt                tmva_lepton_pt                lepton pT                     GeV                               'F'    [50.0000762939,1615.45446777]
tmva_lepton_eta               tmva_lepton_eta               tmva_lepton_eta               lepton #eta                                                     'F'    [-2.39999055862,2.39999818802]
tmva_deltaphi_leptonnextjet   tmva_deltaphi_leptonnextjet   tmva_deltaphi_leptonnextjet   #Delta#phi(l,jet)             rad                               'F'    [1.90734863281e-06,3.14152240753]
NSpec 0


============================================================================ */

#include <vector>
#include <cmath>
#include <string>
#include <iostream>

#define NN new BDTNode
   
#ifndef BDTNode__def
#define BDTNode__def
   
class BDTNode {
   
public:
   
   // constructor of an essentially "empty" node floating in space
   BDTNode ( BDTNode* left,BDTNode* right,
                          int selector, double cutValue, bool cutType, 
                          int nodeType, double purity, double response ) :
   fLeft         ( left         ),
   fRight        ( right        ),
   fSelector     ( selector     ),
   fCutValue     ( cutValue     ),
   fCutType      ( cutType      ),
   fNodeType     ( nodeType     ),
   fPurity       ( purity       ),
   fResponse     ( response     ){
   }

   virtual ~BDTNode();

   // test event if it decends the tree at this node to the right
   virtual bool GoesRight( const std::vector<double>& inputValues ) const;
   BDTNode* GetRight( void )  {return fRight; };

   // test event if it decends the tree at this node to the left 
   virtual bool GoesLeft ( const std::vector<double>& inputValues ) const;
   BDTNode* GetLeft( void ) { return fLeft; };   

   // return  S/(S+B) (purity) at this node (from  training)

   double GetPurity( void ) const { return fPurity; } 
   // return the node type
   int    GetNodeType( void ) const { return fNodeType; }
   double GetResponse(void) const {return fResponse;}

private:

   BDTNode*   fLeft;     // pointer to the left daughter node
   BDTNode*   fRight;    // pointer to the right daughter node
   int                     fSelector; // index of variable used in node selection (decision tree)   
   double                  fCutValue; // cut value appplied on this node to discriminate bkg against sig
   bool                    fCutType;  // true: if event variable > cutValue ==> signal , false otherwise
   int                     fNodeType; // Type of node: -1 == Bkg-leaf, 1 == Signal-leaf, 0 = internal 
   double                  fPurity;   // Purity of node from training
   double                  fResponse; // Regression response value of node
}; 
   
//_______________________________________________________________________
   BDTNode::~BDTNode()
{
   if (fLeft  != NULL) delete fLeft;
   if (fRight != NULL) delete fRight;
}; 
   
//_______________________________________________________________________
bool BDTNode::GoesRight( const std::vector<double>& inputValues ) const
{
   // test event if it decends the tree at this node to the right
   bool result;
     result = (inputValues[fSelector] > fCutValue );
   if (fCutType == true) return result; //the cuts are selecting Signal ;
   else return !result;
}
   
//_______________________________________________________________________
bool BDTNode::GoesLeft( const std::vector<double>& inputValues ) const
{
   // test event if it decends the tree at this node to the left
   if (!this->GoesRight(inputValues)) return true;
   else return false;
}
   
#endif
   
#ifndef IClassifierReader__def
#define IClassifierReader__def

class IClassifierReader {

 public:

   // constructor
   IClassifierReader() : fStatusIsClean( true ) {}
   virtual ~IClassifierReader() {}

   // return classifier response
   virtual double GetMvaValue( const std::vector<double>& inputValues ) const = 0;

   // returns classifier status
   bool IsStatusClean() const { return fStatusIsClean; }

 protected:

   bool fStatusIsClean;
};

#endif

class ReadBDT : public IClassifierReader {

 public:

   // constructor
   ReadBDT( std::vector<std::string>& theInputVars ) 
      : IClassifierReader(),
        fClassName( "ReadBDT" ),
        fNvars( 9 ),
        fIsNormalised( false )
   {      
      // the training input variables
      const char* inputVars[] = { "tmva_n_btags", "tmva_deltaphi_bottomlepton", "tmva_deltaphi_bottomtoptag", "tmva_pseudotop_mass", "tmva_ptbalance", "tmva_wass_pt", "tmva_lepton_pt", "tmva_lepton_eta", "tmva_deltaphi_leptonnextjet" };

      // sanity checks
      if (theInputVars.size() <= 0) {
         std::cout << "Problem in class \"" << fClassName << "\": empty input vector" << std::endl;
         fStatusIsClean = false;
      }

      if (theInputVars.size() != fNvars) {
         std::cout << "Problem in class \"" << fClassName << "\": mismatch in number of input values: "
                   << theInputVars.size() << " != " << fNvars << std::endl;
         fStatusIsClean = false;
      }

      // validate input variables
      for (size_t ivar = 0; ivar < theInputVars.size(); ivar++) {
         if (theInputVars[ivar] != inputVars[ivar]) {
            std::cout << "Problem in class \"" << fClassName << "\": mismatch in input variable names" << std::endl
                      << " for variable [" << ivar << "]: " << theInputVars[ivar].c_str() << " != " << inputVars[ivar] << std::endl;
            fStatusIsClean = false;
         }
      }

      // initialize min and max vectors (for normalisation)
      fVmin[0] = 0;
      fVmax[0] = 0;
      fVmin[1] = 0;
      fVmax[1] = 0;
      fVmin[2] = 0;
      fVmax[2] = 0;
      fVmin[3] = 0;
      fVmax[3] = 0;
      fVmin[4] = 0;
      fVmax[4] = 0;
      fVmin[5] = 0;
      fVmax[5] = 0;
      fVmin[6] = 0;
      fVmax[6] = 0;
      fVmin[7] = 0;
      fVmax[7] = 0;
      fVmin[8] = 0;
      fVmax[8] = 0;

      // initialize input variable types
      fType[0] = 'I';
      fType[1] = 'F';
      fType[2] = 'F';
      fType[3] = 'F';
      fType[4] = 'F';
      fType[5] = 'F';
      fType[6] = 'F';
      fType[7] = 'F';
      fType[8] = 'F';

      // initialize constants
      Initialize();

   }

   // destructor
   virtual ~ReadBDT() {
      Clear(); // method-specific
   }

   // the classifier response
   // "inputValues" is a vector of input values in the same order as the 
   // variables given to the constructor
   double GetMvaValue( const std::vector<double>& inputValues ) const;

 private:

   // method-specific destructor
   void Clear();

   // common member variables
   const char* fClassName;

   const size_t fNvars;
   size_t GetNvar()           const { return fNvars; }
   char   GetType( int ivar ) const { return fType[ivar]; }

   // normalisation of input variables
   const bool fIsNormalised;
   bool IsNormalised() const { return fIsNormalised; }
   double fVmin[9];
   double fVmax[9];
   double NormVariable( double x, double xmin, double xmax ) const {
      // normalise to output range: [-1, 1]
      return 2*(x - xmin)/(xmax - xmin) - 1.0;
   }

   // type of input variable: 'F' or 'I'
   char   fType[9];

   // initialize internal variables
   void Initialize();
   double GetMvaValue__( const std::vector<double>& inputValues ) const;

   // private members (method specific)
   std::vector<BDTNode*> fForest;       // i.e. root nodes of decision trees
   std::vector<double>                fBoostWeights; // the weights applied in the individual boosts
};

double ReadBDT::GetMvaValue__( const std::vector<double>& inputValues ) const
{
   double myMVA = 0;
   double norm  = 0;
   for (unsigned int itree=0; itree<fForest.size(); itree++){
      BDTNode *current = fForest[itree];
      while (current->GetNodeType() == 0) { //intermediate node
         if (current->GoesRight(inputValues)) current=(BDTNode*)current->GetRight();
         else current=(BDTNode*)current->GetLeft();
      }
      myMVA += fBoostWeights[itree] *  current->GetNodeType();
      norm  += fBoostWeights[itree];
   }
   return myMVA /= norm;
};

void ReadBDT::Initialize()
{
  // itree = 0
  fBoostWeights.push_back(0.24322256065212);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 253.478, 0, 1, 0.723827,-99) , 
NN(
NN(
0, 
0, 
-1, 378.884, 0, 1, 0.607311,-99) , 
NN(
0, 
0, 
-1, 2, 1, -1, 0.412569,-99) , 
5, 284.753, 0, 0, 0.439604,-99) , 
8, 1.49593, 0, 0, 0.501448,-99)    );
  // itree = 1
  fBoostWeights.push_back(0.210641);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 237.657, 0, 1, 0.720024,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.662863,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.478867,-99) , 
3, 332.446, 0, 0, 0.553885,-99) , 
NN(
0, 
0, 
-1, 2, 1, -1, 0.422752,-99) , 
5, 216.715, 0, 0, 0.464721,-99) , 
8, 1.64556, 0, 0, 0.5114,-99)    );
  // itree = 2
  fBoostWeights.push_back(0.200306);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 2.20118, 0, 1, 0.794749,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.638004,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.45486,-99) , 
3, 225.77, 0, 0, 0.585818,-99) , 
6, 135.916, 0, 0, 0.666494,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.596298,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.453494,-99) , 
3, 248.238, 0, 0, 0.524145,-99) , 
NN(
0, 
0, 
-1, 2, 1, -1, 0.429869,-99) , 
5, 178.33, 0, 0, 0.474617,-99) , 
8, 1.34633, 0, 0, 0.523111,-99)    );
  // itree = 3
  fBoostWeights.push_back(0.136575);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.816163,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.621678,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.464862,-99) , 
3, 207.257, 0, 0, 0.584098,-99) , 
6, 170.722, 0, 0, 0.633462,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.637755,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.492548,-99) , 
5, 356.385, 0, 0, 0.501222,-99) , 
NN(
0, 
0, 
-1, 236.36, 0, -1, 0.383797,-99) , 
0, 2, 1, 0, 0.479779,-99) , 
8, 1.1967, 0, 0, 0.526264,-99)    );
  // itree = 4
  fBoostWeights.push_back(0.128649);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 256.703, 0, 1, 0.676758,-99) , 
NN(
NN(
0, 
0, 
-1, 141.296, 0, 1, 0.521515,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.543518,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.356586,-99) , 
3, 314.596, 0, 0, 0.410916,-99) , 
0, 2, 1, 0, 0.502487,-99) , 
4, -0.0367324, 0, 0, 0.535623,-99)    );
  // itree = 5
  fBoostWeights.push_back(0.122512);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 176.156, 0, 1, 0.685439,-99) , 
NN(
NN(
0, 
0, 
-1, 1.04694, 0, 1, 0.610057,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.517938,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.450772,-99) , 
5, 165.548, 0, 0, 0.484986,-99) , 
6, 164.619, 0, 0, 0.501244,-99) , 
4, 0.0319944, 0, 0, 0.524154,-99)    );
  // itree = 6
  fBoostWeights.push_back(0.0973516);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 128.704, 0, 1, 0.65948,-99) , 
NN(
NN(
0, 
0, 
-1, 1.19683, 0, 1, 0.609312,-99) , 
NN(
0, 
0, 
-1, 2, 1, -1, 0.480745,-99) , 
6, 177.183, 0, 0, 0.494822,-99) , 
8, 1.79516, 0, 0, 0.519335,-99)    );
  // itree = 7
  fBoostWeights.push_back(0.0934795);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 170.723, 0, 1, 0.701753,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.491965,-99) , 
3, 237.212, 0, 0, 0.6514,-99) , 
NN(
NN(
0, 
0, 
-1, 164.62, 0, 1, 0.566495,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.500878,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.417344,-99) , 
0, 2, 1, 0, 0.48591,-99) , 
3, 452.478, 0, 0, 0.498813,-99) , 
4, -0.0262859, 0, 0, 0.525386,-99)    );
  // itree = 8
  fBoostWeights.push_back(0.10202);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.787464,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.640011,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.467734,-99) , 
3, 213.221, 0, 0, 0.602369,-99) , 
6, 199.094, 0, 0, 0.643592,-99) , 
NN(
NN(
0, 
0, 
-1, 149.394, 0, 1, 0.535528,-99) , 
NN(
0, 
0, 
-1, 2, 1, -1, 0.473543,-99) , 
8, 1.04715, 0, 0, 0.49169,-99) , 
4, -0.0262859, 0, 0, 0.517993,-99)    );
  // itree = 9
  fBoostWeights.push_back(0.0838722);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 199.093, 0, 1, 0.639486,-99) , 
NN(
NN(
0, 
0, 
-1, 177.185, 0, 1, 0.562399,-99) , 
NN(
0, 
0, 
-1, 2, 1, -1, 0.486757,-99) , 
3, 453.124, 0, 0, 0.498866,-99) , 
4, -0.0268423, 0, 0, 0.523486,-99)    );
  // itree = 10
  fBoostWeights.push_back(0.0920779);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.765745,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.61439,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.486863,-99) , 
3, 215.456, 0, 0, 0.583915,-99) , 
6, 199.096, 0, 0, 0.621348,-99) , 
NN(
NN(
0, 
0, 
-1, 141.976, 0, 1, 0.518979,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.51708,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.37406,-99) , 
3, 220.817, 0, 0, 0.448689,-99) , 
0, 2, 1, 0, 0.507185,-99) , 
4, -0.0417071, 0, 0, 0.528549,-99)    );
  // itree = 11
  fBoostWeights.push_back(0.07396);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.771714,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.609875,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.458755,-99) , 
3, 266.296, 0, 0, 0.557025,-99) , 
8, 1.34634, 0, 0, 0.637878,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.593992,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.478523,-99) , 
3, 210.404, 0, 0, 0.567544,-99) , 
NN(
0, 
0, 
-1, 2, 1, -1, 0.490172,-99) , 
4, -0.0366803, 0, 0, 0.501489,-99) , 
6, 177.183, 0, 0, 0.518722,-99)    );
  // itree = 12
  fBoostWeights.push_back(0.0659337);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 1.04704, 0, 1, 0.659787,-99) , 
NN(
NN(
0, 
0, 
-1, 1.34639, 0, 1, 0.56999,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.504223,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.449252,-99) , 
0, 2, 1, 0, 0.495048,-99) , 
4, -0.0361761, 0, 0, 0.506642,-99) , 
6, 199.091, 0, 0, 0.519832,-99)    );
  // itree = 13
  fBoostWeights.push_back(0.0720187);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 1.047, 0, 1, 0.639469,-99) , 
NN(
NN(
0, 
0, 
-1, 1.49597, 0, 1, 0.544859,-99) , 
NN(
0, 
0, 
-1, 93.2486, 0, -1, 0.482874,-99) , 
6, 129.561, 0, 0, 0.49816,-99) , 
5, 325.072, 0, 0, 0.512819,-99)    );
  // itree = 14
  fBoostWeights.push_back(0.0907359);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.770261,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.589997,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.490768,-99) , 
3, 230.263, 0, 0, 0.560177,-99) , 
6, 232.709, 0, 0, 0.584016,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.54206,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.490286,-99) , 
3, 252.91, 0, 0, 0.508617,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.523117,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.450152,-99) , 
6, 140.081, 0, 0, 0.465468,-99) , 
1, 2.24399, 1, 0, 0.494618,-99) , 
4, -0.120886, 0, 0, 0.519224,-99)    );
  // itree = 15
  fBoostWeights.push_back(0.0673521);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 176.159, 0, 1, 0.601435,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.524176,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.49139,-99) , 
2, 1.496, 0, 0, 0.50857,-99) , 
NN(
0, 
0, 
-1, 2.09439, 1, -1, 0.453061,-99) , 
5, 75.4647, 0, 0, 0.502849,-99) , 
4, -0.0254217, 0, 0, 0.519469,-99)    );
  // itree = 16
  fBoostWeights.push_back(0.0559454);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 271.052, 0, 1, 0.661149,-99) , 
NN(
NN(
0, 
0, 
-1, 140.057, 0, 1, 0.576037,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.506138,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.455157,-99) , 
5, 85.311, 0, 0, 0.499782,-99) , 
8, 1.7951, 0, 0, 0.510011,-99) , 
6, 221.929, 0, 0, 0.518827,-99)    );
  // itree = 17
  fBoostWeights.push_back(0.0566475);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.713421,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.590542,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.494956,-99) , 
6, 96.8524, 0, 0, 0.551531,-99) , 
5, 293.84, 0, 0, 0.598315,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.598651,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.505313,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.451935,-99) , 
0, 2, 1, 0, 0.496053,-99) , 
6, 232.706, 0, 0, 0.500085,-99) , 
8, 1.79511, 0, 0, 0.514147,-99)    );
  // itree = 18
  fBoostWeights.push_back(0.0564679);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.675186,-99) , 
NN(
NN(
0, 
0, 
-1, 122.478, 0, 1, 0.549389,-99) , 
NN(
0, 
0, 
-1, 2, 1, -1, 0.486898,-99) , 
8, 1.34628, 0, 0, 0.501489,-99) , 
6, 240.258, 0, 0, 0.508985,-99)    );
  // itree = 19
  fBoostWeights.push_back(0.0485326);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.727055,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.536273,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.478605,-99) , 
1, 1.04722, 0, 0, 0.506629,-99) , 
8, 1.04715, 0, 0, 0.611617,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.570855,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.501345,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.462468,-99) , 
0, 2, 1, 0, 0.49475,-99) , 
8, 2.09435, 0, 0, 0.501539,-99) , 
5, 325.072, 0, 0, 0.512657,-99)    );
  // itree = 20
  fBoostWeights.push_back(0.0424518);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.656075,-99) , 
NN(
NN(
0, 
0, 
-1, 123.158, 0, 1, 0.570367,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.500183,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.457766,-99) , 
5, 111.289, 0, 0, 0.491759,-99) , 
8, 2.09428, 0, 0, 0.499236,-99) , 
5, 389.176, 0, 0, 0.506761,-99)    );
  // itree = 21
  fBoostWeights.push_back(0.047894);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, -0.00907602, 0, 1, 0.653419,-99) , 
NN(
NN(
0, 
0, 
-1, 119.715, 0, 1, 0.56802,-99) , 
NN(
0, 
0, 
-1, 2.3936, 1, -1, 0.488834,-99) , 
8, 2.09435, 0, 0, 0.496287,-99) , 
5, 378.997, 0, 0, 0.504794,-99)    );
  // itree = 22
  fBoostWeights.push_back(0.0508198);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.658037,-99) , 
NN(
NN(
0, 
0, 
-1, 0.0432614, 0, 1, 0.514264,-99) , 
NN(
0, 
0, 
-1, 1.34642, 1, -1, 0.466516,-99) , 
5, 123.032, 0, 0, 0.503797,-99) , 
6, 231.081, 0, 0, 0.511435,-99)    );
  // itree = 23
  fBoostWeights.push_back(0.0475426);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.644026,-99) , 
NN(
NN(
0, 
0, 
-1, 277.898, 0, 1, 0.545264,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.538167,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.488329,-99) , 
3, 520.522, 0, 0, 0.493065,-99) , 
8, 1.94475, 0, 0, 0.499029,-99) , 
6, 232.706, 0, 0, 0.505934,-99)    );
  // itree = 24
  fBoostWeights.push_back(0.0424379);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 2.24403, 0, 1, 0.629017,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.565607,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.504803,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.4784,-99) , 
1, 2.09441, 1, 0, 0.494962,-99) , 
8, 2.24382, 0, 0, 0.500338,-99) , 
5, 379.06, 0, 0, 0.507113,-99)    );
  // itree = 25
  fBoostWeights.push_back(0.0431075);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.677177,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.573505,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.513711,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.487523,-99) , 
3, 332.362, 0, 0, 0.496675,-99) , 
4, 0.101599, 0, 0, 0.501597,-99) , 
5, 433.295, 0, 0, 0.506797,-99)    );
  // itree = 26
  fBoostWeights.push_back(0.0536729);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 2.24406, 0, 1, 0.630982,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.626438,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.492305,-99) , 
8, 1.34637, 0, 0, 0.536363,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.532546,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.487151,-99) , 
2, 2.84239, 0, 0, 0.493921,-99) , 
6, 152.289, 0, 0, 0.500942,-99) , 
5, 379.109, 0, 0, 0.507924,-99)    );
  // itree = 27
  fBoostWeights.push_back(0.0486634);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.722749,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.493003,-99) , 
8, 1.0472, 0, 0, 0.601652,-99) , 
NN(
NN(
0, 
0, 
-1, 307.861, 0, 1, 0.521656,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.507092,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.47574,-99) , 
1, 1.7952, 1, 0, 0.494738,-99) , 
8, 1.04718, 0, 0, 0.50426,-99) , 
6, 199.091, 0, 0, 0.512372,-99)    );
  // itree = 28
  fBoostWeights.push_back(0.0279493);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.639066,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.572123,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.502736,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.456789,-99) , 
5, 64.0281, 0, 0, 0.499597,-99) , 
4, 0.148569, 0, 0, 0.502959,-99) , 
6, 240.774, 0, 0, 0.508573,-99)    );
  // itree = 29
  fBoostWeights.push_back(0.0382193);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.710383,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.499924,-99) , 
8, 1.04717, 0, 0, 0.596427,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.554822,-99) , 
NN(
0, 
0, 
-1, 1.71429, 1, -1, 0.489675,-99) , 
4, 0.15891, 0, 0, 0.4923,-99) , 
6, 199.091, 0, 0, 0.500915,-99)    );
  // itree = 30
  fBoostWeights.push_back(0.0267576);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.651705,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.588089,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.523425,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.497409,-99) , 
6, 143.536, 0, 0, 0.502117,-99) , 
6, 228.57, 0, 0, 0.505186,-99) , 
5, 433.64, 0, 0, 0.509401,-99)    );
  // itree = 31
  fBoostWeights.push_back(0.0301837);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.625748,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.63384,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.471625,-99) , 
8, 0.897479, 0, 0, 0.552659,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.504178,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.449595,-99) , 
7, 1.71433, 1, 0, 0.501697,-99) , 
5, 340.837, 0, 0, 0.504562,-99) , 
6, 240.774, 0, 0, 0.509402,-99)    );
  // itree = 32
  fBoostWeights.push_back(0.0333084);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.621352,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.56056,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.50659,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.487194,-99) , 
3, 229.517, 0, 0, 0.498637,-99) , 
5, 356.854, 0, 0, 0.50129,-99) , 
6, 231.081, 0, 0, 0.50708,-99)    );
  // itree = 33
  fBoostWeights.push_back(0.031985);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.649646,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.576878,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.506581,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.484249,-99) , 
1, 2.3936, 1, 0, 0.499126,-99) , 
6, 228.57, 0, 0, 0.501892,-99) , 
5, 435.019, 0, 0, 0.506137,-99)    );
  // itree = 34
  fBoostWeights.push_back(0.0472602);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.613327,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.539048,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.488185,-99) , 
2, 0.897597, 0, 0, 0.508243,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.501296,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.424459,-99) , 
0, 2, 1, 0, 0.486143,-99) , 
3, 231.087, 0, 0, 0.499256,-99) , 
6, 240.774, 0, 0, 0.503831,-99)    );
  // itree = 35
  fBoostWeights.push_back(0.0345374);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 2.24398, 0, 1, 0.610399,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.550822,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.507949,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.48846,-99) , 
3, 264.576, 0, 0, 0.497896,-99) , 
8, 2.39354, 0, 0, 0.500807,-99) , 
5, 378.997, 0, 0, 0.506607,-99)    );
  // itree = 36
  fBoostWeights.push_back(0.0320782);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.608398,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.576382,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.494653,-99) , 
6, 114.276, 0, 0, 0.539636,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.503063,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.486371,-99) , 
2, 1.496, 0, 0, 0.49526,-99) , 
8, 2.09435, 0, 0, 0.499486,-99) , 
5, 389.176, 0, 0, 0.504611,-99)    );
  // itree = 37
  fBoostWeights.push_back(0.0281889);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.608101,-99) , 
NN(
NN(
0, 
0, 
-1, 1.64539, 0, 1, 0.537204,-99) , 
NN(
0, 
0, 
-1, 1.25697, 1, -1, 0.494096,-99) , 
4, 0.0152552, 0, 0, 0.498904,-99) , 
5, 389.176, 0, 0, 0.504098,-99)    );
  // itree = 38
  fBoostWeights.push_back(0.025972);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.654292,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.583498,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.491765,-99) , 
6, 123.021, 0, 0, 0.543483,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.502676,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.476314,-99) , 
7, -1.25704, 0, 0, 0.499573,-99) , 
4, 0.0534507, 0, 0, 0.503572,-99) , 
5, 445.741, 0, 0, 0.507406,-99)    );
  // itree = 39
  fBoostWeights.push_back(0.0322771);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.604247,-99) , 
NN(
NN(
0, 
0, 
-1, 2, 0, 1, 0.509386,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.502637,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.432932,-99) , 
0, 2, 1, 0, 0.489012,-99) , 
3, 233.888, 0, 0, 0.500914,-99) , 
6, 232.708, 0, 0, 0.50574,-99)    );
  // itree = 40
  fBoostWeights.push_back(0.0208088);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.632445,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.546066,-99) , 
NN(
0, 
0, 
-1, 1.48564, 1, -1, 0.495899,-99) , 
4, 0.101599, 0, 0, 0.499157,-99) , 
5, 433.295, 0, 0, 0.502952,-99)    );
  // itree = 41
  fBoostWeights.push_back(0.031627);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.619117,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.587897,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.493004,-99) , 
6, 124.43, 0, 0, 0.541005,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.510845,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.491498,-99) , 
3, 378.795, 0, 0, 0.496258,-99) , 
8, 2.09435, 0, 0, 0.500581,-99) , 
5, 433.607, 0, 0, 0.503902,-99)    );
  // itree = 42
  fBoostWeights.push_back(0.0345207);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.624553,-99) , 
NN(
NN(
0, 
0, 
-1, 149.246, 0, 1, 0.535142,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.518488,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.490228,-99) , 
2, 0.149601, 1, 0, 0.493471,-99) , 
8, 1.7951, 0, 0, 0.499249,-99) , 
5, 433.295, 0, 0, 0.50277,-99)    );
  // itree = 43
  fBoostWeights.push_back(0.0260337);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.600623,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.547435,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.506958,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.491625,-99) , 
1, 2.5432, 1, 0, 0.502636,-99) , 
6, 195.346, 0, 0, 0.504848,-99) , 
6, 240.774, 0, 0, 0.508707,-99)    );
  // itree = 44
  fBoostWeights.push_back(0.0246632);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.603926,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.543399,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.514123,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.495045,-99) , 
8, 1.13978, 0, 0, 0.500185,-99) , 
8, 2.39354, 0, 0, 0.502707,-99) , 
5, 426.013, 0, 0, 0.505714,-99)    );
  // itree = 45
  fBoostWeights.push_back(0.0253141);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.597113,-99) , 
NN(
NN(
0, 
0, 
-1, 2.09427, 0, 1, 0.506672,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.509273,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.456937,-99) , 
1, 1.64561, 1, 0, 0.481307,-99) , 
7, -1.25704, 0, 0, 0.503702,-99) , 
6, 239.23, 0, 0, 0.507483,-99)    );
  // itree = 46
  fBoostWeights.push_back(0.0160524);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.607565,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.56059,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.500708,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.467372,-99) , 
7, 1.48575, 1, 0, 0.49815,-99) , 
6, 228.57, 0, 0, 0.500373,-99) , 
5, 433.358, 0, 0, 0.503328,-99)    );
  // itree = 47
  fBoostWeights.push_back(0.0307087);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.584498,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.547048,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.494875,-99) , 
6, 167.139, 0, 0, 0.500902,-99) , 
NN(
0, 
0, 
-1, 292.746, 1, -1, 0.483041,-99) , 
8, 0.598387, 0, 0, 0.494668,-99) , 
6, 239.23, 0, 0, 0.498334,-99)    );
  // itree = 48
  fBoostWeights.push_back(0.0273677);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 383.162, 0, 1, 0.562014,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.542981,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.511319,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.493183,-99) , 
4, -0.527821, 1, 0, 0.498196,-99) , 
8, 2.39354, 0, 0, 0.500474,-99) , 
4, 0.0989055, 0, 0, 0.505007,-99)    );
  // itree = 49
  fBoostWeights.push_back(0.0172663);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 437.58, 0, 1, 0.57685,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.549138,-99) , 
NN(
0, 
0, 
-1, 1.71433, 1, -1, 0.497129,-99) , 
6, 210.661, 0, 0, 0.499426,-99) , 
5, 379.109, 0, 0, 0.503428,-99)    );
  // itree = 50
  fBoostWeights.push_back(0.0198146);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.614525,-99) , 
NN(
NN(
0, 
0, 
-1, 289.113, 0, 1, 0.530317,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.524693,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.498531,-99) , 
3, 575.718, 0, 0, 0.500359,-99) , 
8, 1.7951, 0, 0, 0.504424,-99) , 
5, 433.295, 0, 0, 0.507612,-99)    );
  // itree = 51
  fBoostWeights.push_back(0.0298999);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.59546,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.512094,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.494991,-99) , 
3, 211.651, 0, 0, 0.506116,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.512114,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.433213,-99) , 
1, 2.09433, 1, 0, 0.478257,-99) , 
7, 1.48571, 1, 0, 0.503998,-99) , 
6, 240.774, 0, 0, 0.507657,-99)    );
  // itree = 52
  fBoostWeights.push_back(0.0280682);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.601935,-99) , 
NN(
NN(
0, 
0, 
-1, 198.052, 0, 1, 0.513746,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.503175,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.443231,-99) , 
5, 288.902, 1, 0, 0.496805,-99) , 
8, 0.747986, 0, 0, 0.505955,-99) , 
5, 433.295, 0, 0, 0.508636,-99)    );
  // itree = 53
  fBoostWeights.push_back(0.0270194);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.594095,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.508173,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.482935,-99) , 
7, 1.02853, 1, 0, 0.503666,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.455525,-99) , 
7, -1.71429, 0, 0, 0.501572,-99) , 
5, 433.745, 0, 0, 0.504071,-99)    );
  // itree = 54
  fBoostWeights.push_back(0.0515257);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.657846,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.461535,-99) , 
8, 1.04721, 0, 0, 0.550516,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.513983,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.468638,-99) , 
0, 2, 1, 0, 0.506165,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.527515,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.478698,-99) , 
0, 2, 0, 0, 0.485904,-99) , 
1, 1.49601, 1, 0, 0.495211,-99) , 
6, 199.091, 0, 0, 0.499717,-99)    );
  // itree = 55
  fBoostWeights.push_back(0.0271475);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.587328,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.509002,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.490217,-99) , 
3, 217.954, 0, 0, 0.502048,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.463892,-99) , 
7, 1.71421, 1, 0, 0.500326,-99) , 
6, 240.774, 0, 0, 0.503802,-99)    );
  // itree = 56
  fBoostWeights.push_back(0.0143923);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.573667,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.53388,-99) , 
NN(
0, 
0, 
-1, 37.2622, 0, -1, 0.497975,-99) , 
4, 0.101253, 0, 0, 0.500156,-99) , 
5, 389.239, 0, 0, 0.503569,-99)    );
  // itree = 57
  fBoostWeights.push_back(0.0179121);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.585939,-99) , 
NN(
NN(
0, 
0, 
-1, -0.630116, 1, 1, 0.503903,-99) , 
NN(
0, 
0, 
-1, 443.867, 1, -1, 0.477078,-99) , 
5, 103.736, 0, 0, 0.499809,-99) , 
5, 435.019, 0, 0, 0.502148,-99)    );
  // itree = 58
  fBoostWeights.push_back(0.0142002);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.587377,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.560618,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.499539,-99) , 
4, -0.637202, 1, 0, 0.501651,-99) , 
NN(
0, 
0, 
-1, 442.991, 1, -1, 0.482876,-99) , 
5, 103.637, 0, 0, 0.498736,-99) , 
5, 433.607, 0, 0, 0.501199,-99)    );
  // itree = 59
  fBoostWeights.push_back(0.0244191);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.571056,-99) , 
NN(
NN(
0, 
0, 
-1, 296.644, 0, 1, 0.509665,-99) , 
NN(
0, 
0, 
-1, 278.02, 1, -1, 0.490899,-99) , 
8, 0.74796, 0, 0, 0.501038,-99) , 
5, 389.176, 0, 0, 0.50422,-99)    );
  // itree = 60
  fBoostWeights.push_back(0.0417088);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.578735,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.51873,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.479666,-99) , 
0, 2, 1, 0, 0.508599,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.51198,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.47984,-99) , 
6, 122.083, 0, 0, 0.490335,-99) , 
2, 0.897599, 0, 0, 0.500302,-99) , 
6, 239.23, 0, 0, 0.503486,-99)    );
  // itree = 61
  fBoostWeights.push_back(0.0206172);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.559174,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.504747,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.472245,-99) , 
5, 56.4871, 0, 0, 0.502991,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.508458,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.444986,-99) , 
1, 1.49601, 1, 0, 0.471799,-99) , 
7, -1.48572, 0, 0, 0.500688,-99) , 
5, 394.6, 0, 0, 0.503152,-99)    );
  // itree = 62
  fBoostWeights.push_back(0.0232052);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.58053,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.529448,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.495476,-99) , 
8, 2.39354, 0, 0, 0.497418,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.535027,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.429309,-99) , 
1, 1.49602, 1, 0, 0.476234,-99) , 
7, -1.48571, 0, 0, 0.495834,-99) , 
5, 433.407, 0, 0, 0.498217,-99)    );
  // itree = 63
  fBoostWeights.push_back(0.0174996);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.582072,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.523758,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.519518,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.495472,-99) , 
3, 609.552, 0, 0, 0.496907,-99) , 
4, 0.101599, 0, 0, 0.498616,-99) , 
5, 433.295, 0, 0, 0.501003,-99)    );
  // itree = 64
  fBoostWeights.push_back(0.0228446);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.556558,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.503443,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.478899,-99) , 
7, -1.10461, 0, 0, 0.499477,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.513499,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.430198,-99) , 
1, 1.49594, 1, 0, 0.467139,-99) , 
7, 1.48575, 1, 0, 0.497029,-99) , 
6, 231.081, 0, 0, 0.499804,-99)    );
  // itree = 65
  fBoostWeights.push_back(0.0246889);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.562549,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.508956,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.493796,-99) , 
2, 0.598401, 0, 0, 0.503214,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.514864,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.460773,-99) , 
6, 68.1099, 1, 0, 0.482021,-99) , 
5, 85.4428, 0, 0, 0.500914,-99) , 
6, 240.258, 0, 0, 0.503352,-99)    );
  // itree = 66
  fBoostWeights.push_back(0.0229107);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.562128,-99) , 
NN(
NN(
0, 
0, 
-1, 288.332, 0, 1, 0.506556,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.504461,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.440887,-99) , 
5, 267.323, 1, 0, 0.494712,-99) , 
8, 0.747983, 0, 0, 0.501003,-99) , 
4, 0.203987, 0, 0, 0.503268,-99)    );
  // itree = 67
  fBoostWeights.push_back(0.0235623);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0.747898, 0, 1, 0.551189,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.550583,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.49862,-99) , 
5, 333.92, 0, 0, 0.50245,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.504178,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.416961,-99) , 
0, 2, 1, 0, 0.486801,-99) , 
3, 190.785, 0, 0, 0.498052,-99) , 
3, 633.697, 0, 0, 0.501327,-99)    );
  // itree = 68
  fBoostWeights.push_back(0.0224556);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0.897594, 1, 1, 0.554265,-99) , 
NN(
NN(
0, 
0, 
-1, 114.063, 0, 1, 0.513684,-99) , 
NN(
0, 
0, 
-1, 220.529, 0, -1, 0.492324,-99) , 
4, -0.613543, 1, 0, 0.496045,-99) , 
6, 221.301, 0, 0, 0.499245,-99)    );
  // itree = 69
  fBoostWeights.push_back(0.0139757);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.563795,-99) , 
NN(
NN(
0, 
0, 
-1, -0.608971, 1, 1, 0.502495,-99) , 
NN(
0, 
0, 
-1, 372.506, 1, -1, 0.480893,-99) , 
5, 97.4695, 0, 0, 0.499526,-99) , 
4, 0.203987, 0, 0, 0.501932,-99)    );
  // itree = 70
  fBoostWeights.push_back(0.0178365);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.569683,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.504803,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.476464,-99) , 
5, 62.0145, 0, 0, 0.503034,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.466845,-99) , 
7, 1.71423, 1, 0, 0.501457,-99) , 
5, 433.295, 0, 0, 0.503377,-99)    );
  // itree = 71
  fBoostWeights.push_back(0.0207704);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.565885,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.514941,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.494936,-99) , 
3, 419.246, 0, 0, 0.499139,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.464316,-99) , 
7, 1.71429, 1, 0, 0.497593,-99) , 
4, 0.216399, 0, 0, 0.499942,-99)    );
  // itree = 72
  fBoostWeights.push_back(0.0246259);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.611309,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.460568,-99) , 
8, 0.897596, 0, 0, 0.534801,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.507619,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.495215,-99) , 
4, -0.520513, 1, 0, 0.498501,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.466345,-99) , 
7, -1.71428, 0, 0, 0.497057,-99) , 
6, 199.091, 0, 0, 0.500116,-99)    );
  // itree = 73
  fBoostWeights.push_back(0.0280938);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.592582,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.572871,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.498991,-99) , 
5, 331.177, 0, 0, 0.5034,-99) , 
6, 199.091, 0, 0, 0.511112,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.510157,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.492697,-99) , 
4, -0.395302, 0, 0, 0.500038,-99) , 
NN(
0, 
0, 
-1, 1.19678, 0, -1, 0.440908,-99) , 
5, 284.401, 1, 0, 0.491915,-99) , 
8, 0.747964, 0, 0, 0.502293,-99)    );
  // itree = 74
  fBoostWeights.push_back(0.0168971);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.567386,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.516127,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.498747,-99) , 
8, 1.19677, 0, 0, 0.503713,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.46509,-99) , 
7, -1.71417, 0, 0, 0.502011,-99) , 
5, 433.295, 0, 0, 0.50379,-99)    );
  // itree = 75
  fBoostWeights.push_back(0.0219543);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.552713,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.508631,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.479286,-99) , 
7, 1.68163, 1, 0, 0.505998,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.513568,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.491613,-99) , 
1, 2.99199, 0, 0, 0.493499,-99) , 
7, -0.114109, 0, 0, 0.500346,-99) , 
4, 0.197753, 0, 0, 0.502348,-99)    );
  // itree = 76
  fBoostWeights.push_back(0.0219126);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.558788,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.565481,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.49854,-99) , 
5, 292.381, 0, 0, 0.507914,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.502472,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.439679,-99) , 
6, 176.838, 1, 0, 0.496069,-99) , 
8, 0.897559, 0, 0, 0.501164,-99) , 
4, 0.21635, 0, 0, 0.503141,-99)    );
  // itree = 77
  fBoostWeights.push_back(0.0311939);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 341.183, 0, 1, 0.514794,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.508685,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.479975,-99) , 
6, 107.643, 1, 0, 0.498491,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.426523,-99) , 
5, 356.497, 1, 0, 0.493976,-99) , 
8, 0.747973, 0, 0, 0.505192,-99)    );
  // itree = 78
  fBoostWeights.push_back(0.0203748);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.563196,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.547905,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.497592,-99) , 
4, 0.00161465, 0, 0, 0.519275,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.5191,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.494188,-99) , 
3, 152.68, 1, 0, 0.496768,-99) , 
8, 2.09435, 0, 0, 0.498966,-99) , 
3, 780.703, 0, 0, 0.50079,-99)    );
  // itree = 79
  fBoostWeights.push_back(0.0261356);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.576475,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.535552,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.499285,-99) , 
3, 351.885, 0, 0, 0.505796,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.526185,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.48288,-99) , 
3, 300.286, 1, 0, 0.493975,-99) , 
1, 2.39359, 1, 0, 0.50177,-99) , 
5, 433.607, 0, 0, 0.503886,-99)    );
  // itree = 80
  fBoostWeights.push_back(0.031139);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 2, 0, 1, 0.515271,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.505927,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.450252,-99) , 
5, 267.653, 1, 0, 0.497883,-99) , 
3, 260.105, 0, 0, 0.506968,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.519867,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.453282,-99) , 
1, 1.19677, 1, 0, 0.477158,-99) , 
7, 1.48575, 1, 0, 0.504748,-99)    );
  // itree = 81
  fBoostWeights.push_back(0.0317815);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.601174,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.521702,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.495708,-99) , 
2, 2.09439, 0, 0, 0.503451,-99) , 
6, 199.091, 0, 0, 0.512289,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.508421,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.489033,-99) , 
6, 79.8223, 1, 0, 0.497157,-99) , 
NN(
0, 
0, 
-1, 0.74799, 0, -1, 0.457595,-99) , 
5, 284.282, 1, 0, 0.491688,-99) , 
8, 0.897582, 0, 0, 0.500784,-99)    );
  // itree = 82
  fBoostWeights.push_back(0.0196889);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.555004,-99) , 
NN(
NN(
0, 
0, 
-1, -0.537934, 1, 1, 0.506305,-99) , 
NN(
0, 
0, 
-1, 442.864, 1, -1, 0.487759,-99) , 
5, 126.827, 0, 0, 0.501912,-99) , 
6, 232.707, 0, 0, 0.504305,-99)    );
  // itree = 83
  fBoostWeights.push_back(0.0188782);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.554617,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.505627,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.493056,-99) , 
6, 84.0975, 0, 0, 0.500615,-99) , 
NN(
0, 
0, 
-1, 2.84239, 1, -1, 0.485122,-99) , 
7, 0.800002, 1, 0, 0.497012,-99) , 
5, 433.295, 0, 0, 0.498571,-99)    );
  // itree = 84
  fBoostWeights.push_back(0.0151406);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.553294,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.561044,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.499137,-99) , 
4, -0.655874, 1, 0, 0.501109,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.508904,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.469282,-99) , 
2, 0.299234, 1, 0, 0.480053,-99) , 
5, 97.4695, 0, 0, 0.498229,-99) , 
4, 0.203987, 0, 0, 0.500292,-99)    );
  // itree = 85
  fBoostWeights.push_back(0.0173044);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.544508,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.508493,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.498253,-99) , 
3, 235.188, 0, 0, 0.503941,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.508576,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.461317,-99) , 
3, 323.001, 1, 0, 0.488636,-99) , 
5, 85.3848, 0, 0, 0.502278,-99) , 
6, 240.259, 0, 0, 0.503911,-99)    );
  // itree = 86
  fBoostWeights.push_back(0.0255211);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.564723,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.512514,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.493728,-99) , 
4, -0.300537, 1, 0, 0.504389,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.505019,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.451021,-99) , 
2, 2.39357, 1, 0, 0.49125,-99) , 
1, 2.6928, 1, 0, 0.501384,-99) , 
5, 433.407, 0, 0, 0.503135,-99)    );
  // itree = 87
  fBoostWeights.push_back(0.0343591);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 1.54583, 0, 1, 0.57467,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.511343,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.486468,-99) , 
8, 1.54584, 1, 0, 0.503515,-99) , 
5, 325.775, 0, 0, 0.510655,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.516831,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.493514,-99) , 
4, -0.328232, 0, 0, 0.501007,-99) , 
NN(
0, 
0, 
-1, 176.843, 1, -1, 0.446562,-99) , 
5, 284.401, 1, 0, 0.493491,-99) , 
8, 0.747986, 0, 0, 0.502748,-99)    );
  // itree = 88
  fBoostWeights.push_back(0.016346);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.549522,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.528166,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.499911,-99) , 
2, 2.99199, 0, 0, 0.501902,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.512888,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.475353,-99) , 
3, 302.458, 1, 0, 0.483952,-99) , 
1, 2.69279, 1, 0, 0.497808,-99) , 
4, 0.20532, 0, 0, 0.4997,-99)    );
  // itree = 89
  fBoostWeights.push_back(0.021443);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.554836,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.486882,-99) , 
8, 1.34644, 0, 0, 0.526223,-99) , 
NN(
NN(
0, 
0, 
-1, 2.69279, 0, 1, 0.506263,-99) , 
NN(
0, 
0, 
-1, 473.439, 1, -1, 0.488913,-99) , 
1, 2.6928, 1, 0, 0.502544,-99) , 
4, 0.031438, 0, 0, 0.505248,-99)    );
  // itree = 90
  fBoostWeights.push_back(0.0455521);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 326.118, 0, 1, 0.565635,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.530838,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.490311,-99) , 
2, 1.0472, 0, 0, 0.504409,-99) , 
6, 199.092, 0, 0, 0.511385,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.509593,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.462743,-99) , 
5, 269.434, 1, 0, 0.503298,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.531407,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.419973,-99) , 
3, 202.715, 0, 0, 0.45676,-99) , 
0, 2, 1, 0, 0.494436,-99) , 
3, 260.105, 0, 0, 0.503356,-99)    );
  // itree = 91
  fBoostWeights.push_back(0.0123401);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.560607,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.538863,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.498871,-99) , 
4, -0.638324, 1, 0, 0.501107,-99) , 
NN(
0, 
0, 
-1, 370.541, 1, -1, 0.482945,-99) , 
5, 83.3271, 0, 0, 0.499252,-99) , 
5, 435.254, 0, 0, 0.500919,-99)    );
  // itree = 92
  fBoostWeights.push_back(0.0233079);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.538348,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.539962,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.497585,-99) , 
0, 2, 0, 0, 0.50369,-99) , 
NN(
0, 
0, 
-1, 150.479, 1, -1, 0.484369,-99) , 
3, 198.496, 0, 0, 0.497693,-99) , 
3, 669.427, 0, 0, 0.499725,-99)    );
  // itree = 93
  fBoostWeights.push_back(0.0204493);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 125.691, 0, 1, 0.534008,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.534226,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.502818,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.486886,-99) , 
3, 198.495, 0, 0, 0.497387,-99) , 
3, 669.427, 0, 0, 0.499069,-99) , 
8, 2.09435, 0, 0, 0.502537,-99)    );
  // itree = 94
  fBoostWeights.push_back(0.0319077);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.585799,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.513253,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.488118,-99) , 
3, 245.128, 0, 0, 0.503338,-99) , 
5, 325.824, 0, 0, 0.512161,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.508148,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.489913,-99) , 
6, 109.645, 1, 0, 0.502637,-99) , 
NN(
0, 
0, 
-1, 0.598393, 0, -1, 0.468358,-99) , 
5, 271.78, 1, 0, 0.497217,-99) , 
8, 0.897584, 0, 0, 0.503784,-99)    );
  // itree = 95
  fBoostWeights.push_back(0.0161767);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.556302,-99) , 
NN(
NN(
0, 
0, 
-1, 0.299204, 1, 1, 0.505838,-99) , 
NN(
0, 
0, 
-1, 2, 1, -1, 0.491209,-99) , 
5, 144.651, 0, 0, 0.501319,-99) , 
5, 433.407, 0, 0, 0.502803,-99)    );
  // itree = 96
  fBoostWeights.push_back(0.0183764);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.534724,-99) , 
NN(
NN(
0, 
0, 
-1, 126.154, 1, 1, 0.526356,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.502896,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.481472,-99) , 
3, 192.124, 0, 0, 0.497742,-99) , 
3, 141.986, 1, 0, 0.499455,-99) , 
3, 668.416, 0, 0, 0.501227,-99)    );
  // itree = 97
  fBoostWeights.push_back(0.0170013);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.549516,-99) , 
NN(
NN(
0, 
0, 
-1, 179.309, 1, 1, 0.526015,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.519829,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.495718,-99) , 
4, 0.0436022, 0, 0, 0.497649,-99) , 
1, 0.299223, 1, 0, 0.499819,-99) , 
4, 0.21727, 0, 0, 0.501465,-99)    );
  // itree = 98
  fBoostWeights.push_back(0.0138006);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.556429,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.514346,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.499569,-99) , 
3, 379.277, 0, 0, 0.502785,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.502793,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.478567,-99) , 
2, 0.149602, 1, 0, 0.48509,-99) , 
1, 2.8424, 1, 0, 0.49994,-99) , 
5, 435.019, 0, 0, 0.501446,-99)    );
  // itree = 99
  fBoostWeights.push_back(0.0230293);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 1.43187, 0, 1, 0.54753,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.519016,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.491254,-99) , 
1, 1.49619, 1, 0, 0.500552,-99) , 
5, 292.408, 0, 0, 0.508397,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.501382,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.461916,-99) , 
5, 298.297, 1, 0, 0.499456,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.447571,-99) , 
5, 347.995, 1, 0, 0.496101,-99) , 
8, 0.897583, 0, 0, 0.501505,-99)    );
   return;
};
 
// Clean up
inline void ReadBDT::Clear() 
{
   for (unsigned int itree=0; itree<fForest.size(); itree++) { 
      delete fForest[itree]; 
   }
}
   inline double ReadBDT::GetMvaValue( const std::vector<double>& inputValues ) const
   {
      // classifier response value
      double retval = 0;

      // classifier response, sanity check first
      if (!IsStatusClean()) {
         std::cout << "Problem in class \"" << fClassName << "\": cannot return classifier response"
                   << " because status is dirty" << std::endl;
         retval = 0;
      }
      else {
         if (IsNormalised()) {
            // normalise variables
            std::vector<double> iV;
            iV.reserve(inputValues.size());
            int ivar = 0;
            for (std::vector<double>::const_iterator varIt = inputValues.begin();
                 varIt != inputValues.end(); varIt++, ivar++) {
               iV.push_back(NormVariable( *varIt, fVmin[ivar], fVmax[ivar] ));
            }
            retval = GetMvaValue__( iV );
         }
         else {
            retval = GetMvaValue__( inputValues );
         }
      }

      return retval;
   }
