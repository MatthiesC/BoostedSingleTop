// Class: ReadBDT_100_25_05_20
// Automatically generated by MethodBase::MakeClass
//

/* configuration options =====================================================

#GEN -*-*-*-*-*-*-*-*-*-*-*- general info -*-*-*-*-*-*-*-*-*-*-*-

Method         : BDT::BDT_100_25_05_20
TMVA Release   : 4.2.1         [262657]
ROOT Release   : 6.06/01       [394753]
Creator        : matthies
Date           : Tue Sep 18 22:23:28 2018
Host           : Linux vocms0301.cern.ch 2.6.32-642.4.2.el6.x86_64 #1 SMP Wed Aug 24 09:19:54 CEST 2016 x86_64 x86_64 x86_64 GNU/Linux
Dir            : /nfs/dust/cms/user/matthies/Analysis_80x_v5/CMSSW_8_0_24_patch1/src/UHH2/BoostedSingleTop/tmva_comb
Training events: 274422
Analysis type  : [Classification]


#OPT -*-*-*-*-*-*-*-*-*-*-*-*- options -*-*-*-*-*-*-*-*-*-*-*-*-

# Set by User:
V: "False" [Verbose output (short form of "VerbosityLevel" below - overrides the latter one)]
H: "False" [Print method-specific help message]
NTrees: "100" [Number of trees in the forest]
MaxDepth: "3" [Max depth of the decision tree allowed]
MinNodeSize: "2.5%" [Minimum percentage of training events required in a leaf node (default: Classification: 5%, Regression: 0.2%)]
nCuts: "20" [Number of grid points in variable range used in finding optimal cut in node splitting]
BoostType: "AdaBoost" [Boosting type for the trees in the forest (note: AdaCost is still experimental)]
UseBaggedBoost: "True" [Use only a random subsample of all events for growing the trees in each boost iteration.]
AdaBoostBeta: "5.000000e-01" [Learning rate  for AdaBoost algorithm]
BaggedSampleFraction: "5.000000e-01" [Relative size of bagged event sample to original size of the data sample (used whenever bagging is used (i.e. UseBaggedBoost, Bagging,)]
SeparationType: "giniindex" [Separation criterion for node splitting]
# Default:
VerbosityLevel: "Default" [Verbosity level]
VarTransform: "None" [List of variable transformations performed before training, e.g., "D_Background,P_Signal,G,N_AllClasses" for: "Decorrelation, PCA-transformation, Gaussianisation, Normalisation, each for the given class of events ('AllClasses' denotes all events of all classes, if no class indication is given, 'All' is assumed)"]
CreateMVAPdfs: "False" [Create PDFs for classifier outputs (signal and background)]
IgnoreNegWeightsInTraining: "False" [Events with negative weights are ignored in the training (but are included for testing and performance evaluation)]
AdaBoostR2Loss: "quadratic" [Type of Loss function in AdaBoostR2]
Shrinkage: "1.000000e+00" [Learning rate for GradBoost algorithm]
UseRandomisedTrees: "False" [Determine at each node splitting the cut variable only as the best out of a random subset of variables (like in RandomForests)]
UseNvars: "3" [Size of the subset of variables used with RandomisedTree option]
UsePoissonNvars: "True" [Interpret "UseNvars" not as fixed number but as mean of a Possion distribution in each split with RandomisedTree option]
UseYesNoLeaf: "True" [Use Sig or Bkg categories, or the purity=S/(S+B) as classification of the leaf node -> Real-AdaBoost]
NegWeightTreatment: "inverseboostnegweights" [How to treat events with negative weights in the BDT training (particular the boosting) : IgnoreInTraining;  Boost With inverse boostweight; Pair events with negative and positive weights in traning sample and *annihilate* them (experimental!)]
Css: "1.000000e+00" [AdaCost: cost of true signal selected signal]
Cts_sb: "1.000000e+00" [AdaCost: cost of true signal selected bkg]
Ctb_ss: "1.000000e+00" [AdaCost: cost of true bkg    selected signal]
Cbb: "1.000000e+00" [AdaCost: cost of true bkg    selected bkg ]
NodePurityLimit: "5.000000e-01" [In boosting/pruning, nodes with purity > NodePurityLimit are signal; background otherwise.]
DoBoostMonitor: "False" [Create control plot with ROC integral vs tree number]
UseFisherCuts: "False" [Use multivariate splits using the Fisher criterion]
MinLinCorrForFisher: "8.000000e-01" [The minimum linear correlation between two variables demanded for use in Fisher criterion in node splitting]
UseExclusiveVars: "False" [Variables already used in fisher criterion are not anymore analysed individually for node splitting]
DoPreselection: "False" [and and apply automatic pre-selection for 100% efficient signal (bkg) cuts prior to training]
SigToBkgFraction: "1.000000e+00" [Sig to Bkg ratio used in Training (similar to NodePurityLimit, which cannot be used in real adaboost]
PruneMethod: "nopruning" [Note: for BDTs use small trees (e.g.MaxDepth=3) and NoPruning:  Pruning: Method used for pruning (removal) of statistically insignificant branches ]
PruneStrength: "0.000000e+00" [Pruning strength]
PruningValFraction: "5.000000e-01" [Fraction of events to use for optimizing automatic pruning.]
nEventsMin: "0" [deprecated: Use MinNodeSize (in % of training events) instead]
UseBaggedGrad: "False" [deprecated: Use *UseBaggedBoost* instead:  Use only a random subsample of all events for growing the trees in each iteration.]
GradBaggingFraction: "5.000000e-01" [deprecated: Use *BaggedSampleFraction* instead: Defines the fraction of events to be used in each iteration, e.g. when UseBaggedGrad=kTRUE. ]
UseNTrainEvents: "0" [deprecated: Use *BaggedSampleFraction* instead: Number of randomly picked training events used in randomised (and bagged) trees]
NNodesMax: "0" [deprecated: Use MaxDepth instead to limit the tree size]
##


#VAR -*-*-*-*-*-*-*-*-*-*-*-* variables *-*-*-*-*-*-*-*-*-*-*-*-

NVar 8
tmva_deltaphi_bottomlepton    tmva_deltaphi_bottomlepton    tmva_deltaphi_bottomlepton    #Delta#phi(l,b)               rad                               'F'    [5.96046447754e-06,3.14158797264]
tmva_deltaphi_bottomtoptag    tmva_deltaphi_bottomtoptag    tmva_deltaphi_bottomtoptag    #Delta#phi(t,b)               rad                               'F'    [1.51991844177e-06,3.14158964157]
tmva_pseudotop_mass           tmva_pseudotop_mass           tmva_pseudotop_mass           l#nub mass                    GeV                               'F'    [86.8835525513,3932.9206543]
tmva_ptbalance                tmva_ptbalance                tmva_ptbalance                pT balance                                                      'F'    [-0.99961078167,4.64822101593]
tmva_wass_pt                  tmva_wass_pt                  tmva_wass_pt                  asso. W pT                    GeV                               'F'    [0.213053271174,2188.19360352]
tmva_lepton_pt                tmva_lepton_pt                tmva_lepton_pt                lepton pT                     GeV                               'F'    [50.0001106262,1194.46325684]
tmva_lepton_eta               tmva_lepton_eta               tmva_lepton_eta               lepton #eta                                                     'F'    [-2.39986610413,2.39999628067]
tmva_deltaphi_leptonnextjet   tmva_deltaphi_leptonnextjet   tmva_deltaphi_leptonnextjet   #Delta#phi(l,jet)             rad                               'F'    [9.05990600586e-06,3.14136242867]
NSpec 0


============================================================================ */

#include <vector>
#include <cmath>
#include <string>
#include <iostream>

#define NN new BDT_100_25_05_20Node
   
#ifndef BDT_100_25_05_20Node__def
#define BDT_100_25_05_20Node__def
   
class BDT_100_25_05_20Node {
   
public:
   
   // constructor of an essentially "empty" node floating in space
   BDT_100_25_05_20Node ( BDT_100_25_05_20Node* left,BDT_100_25_05_20Node* right,
                          int selector, double cutValue, bool cutType, 
                          int nodeType, double purity, double response ) :
   fLeft         ( left         ),
   fRight        ( right        ),
   fSelector     ( selector     ),
   fCutValue     ( cutValue     ),
   fCutType      ( cutType      ),
   fNodeType     ( nodeType     ),
   fPurity       ( purity       ),
   fResponse     ( response     ){
   }

   virtual ~BDT_100_25_05_20Node();

   // test event if it decends the tree at this node to the right
   virtual bool GoesRight( const std::vector<double>& inputValues ) const;
   BDT_100_25_05_20Node* GetRight( void )  {return fRight; };

   // test event if it decends the tree at this node to the left 
   virtual bool GoesLeft ( const std::vector<double>& inputValues ) const;
   BDT_100_25_05_20Node* GetLeft( void ) { return fLeft; };   

   // return  S/(S+B) (purity) at this node (from  training)

   double GetPurity( void ) const { return fPurity; } 
   // return the node type
   int    GetNodeType( void ) const { return fNodeType; }
   double GetResponse(void) const {return fResponse;}

private:

   BDT_100_25_05_20Node*   fLeft;     // pointer to the left daughter node
   BDT_100_25_05_20Node*   fRight;    // pointer to the right daughter node
   int                     fSelector; // index of variable used in node selection (decision tree)   
   double                  fCutValue; // cut value appplied on this node to discriminate bkg against sig
   bool                    fCutType;  // true: if event variable > cutValue ==> signal , false otherwise
   int                     fNodeType; // Type of node: -1 == Bkg-leaf, 1 == Signal-leaf, 0 = internal 
   double                  fPurity;   // Purity of node from training
   double                  fResponse; // Regression response value of node
}; 
   
//_______________________________________________________________________
   BDT_100_25_05_20Node::~BDT_100_25_05_20Node()
{
   if (fLeft  != NULL) delete fLeft;
   if (fRight != NULL) delete fRight;
}; 
   
//_______________________________________________________________________
bool BDT_100_25_05_20Node::GoesRight( const std::vector<double>& inputValues ) const
{
   // test event if it decends the tree at this node to the right
   bool result;
     result = (inputValues[fSelector] > fCutValue );
   if (fCutType == true) return result; //the cuts are selecting Signal ;
   else return !result;
}
   
//_______________________________________________________________________
bool BDT_100_25_05_20Node::GoesLeft( const std::vector<double>& inputValues ) const
{
   // test event if it decends the tree at this node to the left
   if (!this->GoesRight(inputValues)) return true;
   else return false;
}
   
#endif
   
#ifndef IClassifierReader__def
#define IClassifierReader__def

class IClassifierReader {

 public:

   // constructor
   IClassifierReader() : fStatusIsClean( true ) {}
   virtual ~IClassifierReader() {}

   // return classifier response
   virtual double GetMvaValue( const std::vector<double>& inputValues ) const = 0;

   // returns classifier status
   bool IsStatusClean() const { return fStatusIsClean; }

 protected:

   bool fStatusIsClean;
};

#endif

class ReadBDT_100_25_05_20 : public IClassifierReader {

 public:

   // constructor
   ReadBDT_100_25_05_20( std::vector<std::string>& theInputVars ) 
      : IClassifierReader(),
        fClassName( "ReadBDT_100_25_05_20" ),
        fNvars( 8 ),
        fIsNormalised( false )
   {      
      // the training input variables
      const char* inputVars[] = { "tmva_deltaphi_bottomlepton", "tmva_deltaphi_bottomtoptag", "tmva_pseudotop_mass", "tmva_ptbalance", "tmva_wass_pt", "tmva_lepton_pt", "tmva_lepton_eta", "tmva_deltaphi_leptonnextjet" };

      // sanity checks
      if (theInputVars.size() <= 0) {
         std::cout << "Problem in class \"" << fClassName << "\": empty input vector" << std::endl;
         fStatusIsClean = false;
      }

      if (theInputVars.size() != fNvars) {
         std::cout << "Problem in class \"" << fClassName << "\": mismatch in number of input values: "
                   << theInputVars.size() << " != " << fNvars << std::endl;
         fStatusIsClean = false;
      }

      // validate input variables
      for (size_t ivar = 0; ivar < theInputVars.size(); ivar++) {
         if (theInputVars[ivar] != inputVars[ivar]) {
            std::cout << "Problem in class \"" << fClassName << "\": mismatch in input variable names" << std::endl
                      << " for variable [" << ivar << "]: " << theInputVars[ivar].c_str() << " != " << inputVars[ivar] << std::endl;
            fStatusIsClean = false;
         }
      }

      // initialize min and max vectors (for normalisation)
      fVmin[0] = 0;
      fVmax[0] = 0;
      fVmin[1] = 0;
      fVmax[1] = 0;
      fVmin[2] = 0;
      fVmax[2] = 0;
      fVmin[3] = 0;
      fVmax[3] = 0;
      fVmin[4] = 0;
      fVmax[4] = 0;
      fVmin[5] = 0;
      fVmax[5] = 0;
      fVmin[6] = 0;
      fVmax[6] = 0;
      fVmin[7] = 0;
      fVmax[7] = 0;

      // initialize input variable types
      fType[0] = 'F';
      fType[1] = 'F';
      fType[2] = 'F';
      fType[3] = 'F';
      fType[4] = 'F';
      fType[5] = 'F';
      fType[6] = 'F';
      fType[7] = 'F';

      // initialize constants
      Initialize();

   }

   // destructor
   virtual ~ReadBDT_100_25_05_20() {
      Clear(); // method-specific
   }

   // the classifier response
   // "inputValues" is a vector of input values in the same order as the 
   // variables given to the constructor
   double GetMvaValue( const std::vector<double>& inputValues ) const;

 private:

   // method-specific destructor
   void Clear();

   // common member variables
   const char* fClassName;

   const size_t fNvars;
   size_t GetNvar()           const { return fNvars; }
   char   GetType( int ivar ) const { return fType[ivar]; }

   // normalisation of input variables
   const bool fIsNormalised;
   bool IsNormalised() const { return fIsNormalised; }
   double fVmin[8];
   double fVmax[8];
   double NormVariable( double x, double xmin, double xmax ) const {
      // normalise to output range: [-1, 1]
      return 2*(x - xmin)/(xmax - xmin) - 1.0;
   }

   // type of input variable: 'F' or 'I'
   char   fType[8];

   // initialize internal variables
   void Initialize();
   double GetMvaValue__( const std::vector<double>& inputValues ) const;

   // private members (method specific)
   std::vector<BDT_100_25_05_20Node*> fForest;       // i.e. root nodes of decision trees
   std::vector<double>                fBoostWeights; // the weights applied in the individual boosts
};

double ReadBDT_100_25_05_20::GetMvaValue__( const std::vector<double>& inputValues ) const
{
   double myMVA = 0;
   double norm  = 0;
   for (unsigned int itree=0; itree<fForest.size(); itree++){
      BDT_100_25_05_20Node *current = fForest[itree];
      while (current->GetNodeType() == 0) { //intermediate node
         if (current->GoesRight(inputValues)) current=(BDT_100_25_05_20Node*)current->GetRight();
         else current=(BDT_100_25_05_20Node*)current->GetLeft();
      }
      myMVA += fBoostWeights[itree] *  current->GetNodeType();
      norm  += fBoostWeights[itree];
   }
   return myMVA /= norm;
};

void ReadBDT_100_25_05_20::Initialize()
{
  // itree = 0
  fBoostWeights.push_back(0.361153600663058);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 159.005, 0, 1, 0.702312,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.5133,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.33703,-99) , 
3, -0.281375, 0, 0, 0.431354,-99) , 
NN(
0, 
0, 
-1, 1.34652, 1, -1, 0.25317,-99) , 
2, 240.556, 0, 0, 0.356158,-99) , 
7, 1.49579, 0, 0, 0.501157,-99)    );
  // itree = 1
  fBoostWeights.push_back(0.312814);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 318.591, 0, 1, 0.785269,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.635901,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.48225,-99) , 
3, -0.147392, 0, 0, 0.580457,-99) , 
5, 158.966, 0, 0, 0.644534,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.643242,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.451219,-99) , 
2, 440.906, 0, 0, 0.543692,-99) , 
NN(
0, 
0, 
-1, 243.43, 0, -1, 0.343506,-99) , 
5, 189.952, 0, 0, 0.364556,-99) , 
7, 1.3463, 0, 0, 0.492443,-99)    );
  // itree = 2
  fBoostWeights.push_back(0.253392);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 172.278, 0, 1, 0.633461,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.528259,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.404169,-99) , 
5, 143.167, 0, 0, 0.438938,-99) , 
NN(
0, 
0, 
-1, 2.09456, 1, -1, 0.330262,-99) , 
2, 240.869, 0, 0, 0.393298,-99) , 
7, 1.34622, 0, 0, 0.50488,-99)    );
  // itree = 3
  fBoostWeights.push_back(0.221257);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 158.966, 0, 1, 0.638726,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.636557,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.455091,-99) , 
1, 1.04719, 0, 0, 0.484155,-99) , 
NN(
0, 
0, 
-1, 204.996, 0, -1, 0.366651,-99) , 
2, 263.974, 0, 0, 0.429878,-99) , 
7, 1.79495, 0, 0, 0.500313,-99)    );
  // itree = 4
  fBoostWeights.push_back(0.172654);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 350.523, 0, 1, 0.71193,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.582147,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.481562,-99) , 
5, 112.279, 0, 0, 0.516563,-99) , 
5, 158.998, 0, 0, 0.570415,-99) , 
NN(
0, 
0, 
-1, 263.823, 0, -1, 0.417544,-99) , 
7, 1.04713, 0, 0, 0.503536,-99)    );
  // itree = 5
  fBoostWeights.push_back(0.172922);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.775209,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.606018,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.457974,-99) , 
2, 223.855, 0, 0, 0.587994,-99) , 
5, 213.506, 0, 0, 0.625984,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.545048,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.447802,-99) , 
7, 0.74773, 0, 0, 0.510127,-99) , 
NN(
0, 
0, 
-1, 1.4961, 1, -1, 0.403405,-99) , 
2, 240.869, 0, 0, 0.471465,-99) , 
3, -0.049696, 0, 0, 0.516957,-99)    );
  // itree = 6
  fBoostWeights.push_back(0.140672);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 260.17, 0, 1, 0.731674,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.571898,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.435455,-99) , 
2, 197.02, 0, 0, 0.558484,-99) , 
5, 213.441, 0, 0, 0.589418,-99) , 
NN(
NN(
0, 
0, 
-1, -0.343081, 0, 1, 0.557132,-99) , 
NN(
0, 
0, 
-1, 242.624, 0, -1, 0.449522,-99) , 
7, 1.94421, 0, 0, 0.465613,-99) , 
3, -0.0994156, 0, 0, 0.512716,-99)    );
  // itree = 7
  fBoostWeights.push_back(0.0987835);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0.897085, 0, 1, 0.673098,-99) , 
NN(
NN(
0, 
0, 
-1, 1.64522, 0, 1, 0.569715,-99) , 
NN(
0, 
0, 
-1, 0.897479, 0, -1, 0.473816,-99) , 
3, -0.0329159, 0, 0, 0.496156,-99) , 
5, 213.431, 0, 0, 0.512854,-99)    );
  // itree = 8
  fBoostWeights.push_back(0.088094);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 1.04714, 0, 1, 0.674331,-99) , 
NN(
NN(
0, 
0, 
-1, 135.606, 0, 1, 0.520835,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.503634,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.421003,-99) , 
1, 1.34679, 1, 0, 0.448083,-99) , 
2, 227.252, 0, 0, 0.500326,-99) , 
5, 213.431, 0, 0, 0.516831,-99)    );
  // itree = 9
  fBoostWeights.push_back(0.0835457);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0.897573, 0, 1, 0.654849,-99) , 
NN(
NN(
0, 
0, 
-1, 290.451, 0, 1, 0.517929,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.518114,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.455736,-99) , 
7, 0.14958, 1, 0, 0.464117,-99) , 
7, 1.04704, 0, 0, 0.493897,-99) , 
5, 206.668, 0, 0, 0.511112,-99)    );
  // itree = 10
  fBoostWeights.push_back(0.0933997);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.737781,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.560261,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.487979,-99) , 
5, 133.035, 0, 0, 0.51355,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.50209,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.406727,-99) , 
1, 1.34655, 1, 0, 0.436344,-99) , 
2, 221.163, 0, 0, 0.493916,-99) , 
5, 267.993, 0, 0, 0.504128,-99)    );
  // itree = 11
  fBoostWeights.push_back(0.0574025);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 1.34633, 0, 1, 0.67996,-99) , 
NN(
NN(
0, 
0, 
-1, 353.93, 0, 1, 0.555438,-99) , 
NN(
0, 
0, 
-1, 1.25693, 1, -1, 0.489458,-99) , 
3, 0.0190617, 0, 0, 0.500153,-99) , 
5, 236.331, 0, 0, 0.512185,-99)    );
  // itree = 12
  fBoostWeights.push_back(0.0661273);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.692179,-99) , 
NN(
NN(
0, 
0, 
-1, 159.414, 0, 1, 0.543167,-99) , 
NN(
0, 
0, 
-1, -1.02852, 0, -1, 0.484801,-99) , 
7, 1.64535, 0, 0, 0.506115,-99) , 
5, 258.892, 0, 0, 0.514598,-99)    );
  // itree = 13
  fBoostWeights.push_back(0.0834957);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.697299,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.535048,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.473046,-99) , 
2, 216.013, 0, 0, 0.519964,-99) , 
NN(
0, 
0, 
-1, 1.81226, 1, -1, 0.454624,-99) , 
6, 1.02861, 1, 0, 0.508861,-99) , 
5, 267.993, 0, 0, 0.516395,-99)    );
  // itree = 14
  fBoostWeights.push_back(0.0659965);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.690972,-99) , 
NN(
NN(
0, 
0, 
-1, 365.245, 0, 1, 0.519609,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.512157,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.428929,-99) , 
5, 164.098, 0, 0, 0.443316,-99) , 
6, -1.02854, 0, 0, 0.507256,-99) , 
5, 267.908, 0, 0, 0.514684,-99)    );
  // itree = 15
  fBoostWeights.push_back(0.0596873);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.685091,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.516355,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.458626,-99) , 
6, 1.25699, 1, 0, 0.508108,-99) , 
NN(
0, 
0, 
-1, 70.7595, 0, -1, 0.459068,-99) , 
6, -1.02842, 0, 0, 0.500135,-99) , 
5, 267.993, 0, 0, 0.507528,-99)    );
  // itree = 16
  fBoostWeights.push_back(0.0499829);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.670845,-99) , 
NN(
NN(
0, 
0, 
-1, 174.511, 0, 1, 0.528742,-99) , 
NN(
0, 
0, 
-1, 2.54319, 1, -1, 0.484085,-99) , 
3, -0.0323699, 0, 0, 0.495244,-99) , 
5, 267.907, 0, 0, 0.502015,-99)    );
  // itree = 17
  fBoostWeights.push_back(0.0733198);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.664519,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.527689,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.475326,-99) , 
5, 89.79, 0, 0, 0.507952,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.508715,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.399607,-99) , 
5, 79.8362, 1, 0, 0.443954,-99) , 
0, 0.747987, 0, 0, 0.500997,-99) , 
5, 258.892, 0, 0, 0.5084,-99)    );
  // itree = 18
  fBoostWeights.push_back(0.0390872);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.652436,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.503539,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.470628,-99) , 
5, 69.8941, 0, 0, 0.49671,-99) , 
NN(
0, 
0, 
-1, 360.817, 0, -1, 0.45309,-99) , 
6, 1.25707, 1, 0, 0.491555,-99) , 
5, 258.892, 0, 0, 0.498661,-99)    );
  // itree = 19
  fBoostWeights.push_back(0.0555539);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.673261,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.570771,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.492899,-99) , 
5, 174.552, 0, 0, 0.50511,-99) , 
NN(
0, 
0, 
-1, 153.805, 1, -1, 0.470872,-99) , 
7, 0.89748, 0, 0, 0.492148,-99) , 
5, 267.993, 0, 0, 0.49944,-99)    );
  // itree = 20
  fBoostWeights.push_back(0.0469521);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.67214,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.631224,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.496614,-99) , 
3, 0.015073, 0, 0, 0.562944,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.52887,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.486779,-99) , 
5, 161.297, 0, 0, 0.493934,-99) , 
4, 370.594, 0, 0, 0.498073,-99) , 
5, 283.738, 0, 0, 0.50324,-99)    );
  // itree = 21
  fBoostWeights.push_back(0.0319352);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.640493,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.59379,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.501742,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.462945,-99) , 
2, 200.597, 0, 0, 0.493981,-99) , 
4, 422.392, 0, 0, 0.496666,-99) , 
5, 267.993, 0, 0, 0.50208,-99)    );
  // itree = 22
  fBoostWeights.push_back(0.0558229);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 1.34633, 0, 1, 0.623486,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.516163,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.468352,-99) , 
6, -1.02842, 0, 0, 0.508221,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.505732,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.44061,-99) , 
7, 0.582675, 0, 0, 0.46129,-99) , 
0, 0.748001, 0, 0, 0.503036,-99) , 
5, 236.331, 0, 0, 0.510746,-99)    );
  // itree = 23
  fBoostWeights.push_back(0.0327735);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.655982,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.589412,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.503445,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.467361,-99) , 
2, 205.897, 0, 0, 0.495735,-99) , 
4, 422.653, 0, 0, 0.498392,-99) , 
5, 283.253, 0, 0, 0.503246,-99)    );
  // itree = 24
  fBoostWeights.push_back(0.0405479);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 1.64539, 0, 1, 0.609288,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.578509,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.492561,-99) , 
5, 238.734, 0, 0, 0.495635,-99) , 
NN(
0, 
0, 
-1, 112.049, 1, -1, 0.444765,-99) , 
6, -1.25715, 0, 0, 0.489887,-99) , 
4, 404.043, 0, 0, 0.49644,-99)    );
  // itree = 25
  fBoostWeights.push_back(0.036448);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.633369,-99) , 
NN(
NN(
0, 
0, 
-1, 299.866, 0, 1, 0.51586,-99) , 
NN(
0, 
0, 
-1, 2.99196, 1, -1, 0.48947,-99) , 
7, 1.04706, 0, 0, 0.504286,-99) , 
5, 267.994, 0, 0, 0.509341,-99)    );
  // itree = 26
  fBoostWeights.push_back(0.0432833);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.680198,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.472778,-99) , 
7, 1.34633, 0, 0, 0.592593,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.522539,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.494952,-99) , 
2, 355.442, 0, 0, 0.504563,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.528945,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.4421,-99) , 
1, 1.34637, 0, 0, 0.463482,-99) , 
6, -1.25701, 0, 0, 0.4999,-99) , 
5, 236.602, 0, 0, 0.505454,-99)    );
  // itree = 27
  fBoostWeights.push_back(0.0306371);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.618974,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.506428,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.434684,-99) , 
6, 1.81166, 1, 0, 0.503548,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.437539,-99) , 
6, -1.71427, 0, 0, 0.500567,-99) , 
5, 267.993, 0, 0, 0.50507,-99)    );
  // itree = 28
  fBoostWeights.push_back(0.038564);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.609253,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.515441,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.489578,-99) , 
1, 0.8976, 0, 0, 0.498329,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.407776,-99) , 
6, -1.71414, 0, 0, 0.494263,-99) , 
5, 267.993, 0, 0, 0.498633,-99)    );
  // itree = 29
  fBoostWeights.push_back(0.0444903);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.624036,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.513036,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.410582,-99) , 
6, 1.71435, 1, 0, 0.507946,-99) , 
NN(
0, 
0, 
-1, 184.949, 1, -1, 0.478667,-99) , 
7, 0.74792, 0, 0, 0.499006,-99) , 
5, 267.994, 0, 0, 0.503762,-99)    );
  // itree = 30
  fBoostWeights.push_back(0.0272702);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.606675,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.542729,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.498107,-99) , 
2, 510.574, 0, 0, 0.503354,-99) , 
NN(
0, 
0, 
-1, 91.5132, 1, -1, 0.449324,-99) , 
6, -1.48545, 0, 0, 0.499441,-99) , 
5, 267.994, 0, 0, 0.503599,-99)    );
  // itree = 31
  fBoostWeights.push_back(0.0292735);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.613166,-99) , 
NN(
NN(
0, 
0, 
-1, -0.114656, 0, 1, 0.533257,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.502038,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.477092,-99) , 
6, 0.800042, 1, 0, 0.496158,-99) , 
1, 0.149605, 1, 0, 0.501498,-99) , 
5, 267.907, 0, 0, 0.505738,-99)    );
  // itree = 32
  fBoostWeights.push_back(0.0455877);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.616046,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.57531,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.551829,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.486257,-99) , 
7, 0.149583, 1, 0, 0.490427,-99) , 
5, 242.667, 0, 0, 0.493529,-99) , 
4, 422.699, 0, 0, 0.49911,-99)    );
  // itree = 33
  fBoostWeights.push_back(0.0390868);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.613669,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.578394,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.499502,-99) , 
1, 1.49598, 0, 0, 0.507916,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.523688,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.453899,-99) , 
2, 194.066, 0, 0, 0.474777,-99) , 
2, 218.787, 0, 0, 0.49982,-99) , 
4, 448.537, 0, 0, 0.503623,-99)    );
  // itree = 34
  fBoostWeights.push_back(0.0273333);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.608405,-99) , 
NN(
NN(
0, 
0, 
-1, 0.16262, 0, 1, 0.506923,-99) , 
NN(
0, 
0, 
-1, 99.6363, 1, -1, 0.46253,-99) , 
6, -1.48542, 0, 0, 0.503634,-99) , 
5, 258.891, 0, 0, 0.508363,-99)    );
  // itree = 35
  fBoostWeights.push_back(0.0168628);
  fForest.push_back( 
NN(
0, 
0, 
-1, 267.993, 0, 1, 0.508431,-99)    );
  // itree = 36
  fBoostWeights.push_back(0.0368452);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.613993,-99) , 
NN(
NN(
0, 
0, 
-1, 314.722, 0, 1, 0.522054,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.541037,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.492837,-99) , 
5, 195.329, 0, 0, 0.497849,-99) , 
1, 0.897611, 0, 0, 0.506179,-99) , 
5, 267.994, 0, 0, 0.510318,-99)    );
  // itree = 37
  fBoostWeights.push_back(0.0203142);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.593817,-99) , 
NN(
NN(
0, 
0, 
-1, 1.6445, 0, 1, 0.545049,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.529448,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.498109,-99) , 
3, -0.55838, 1, 0, 0.501329,-99) , 
4, 371.941, 0, 0, 0.503767,-99) , 
5, 267.994, 0, 0, 0.507069,-99)    );
  // itree = 38
  fBoostWeights.push_back(0.0498392);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.607985,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.514031,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.443663,-99) , 
6, -1.71404, 0, 0, 0.510661,-99) , 
5, 267.908, 0, 0, 0.514271,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.52673,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.450191,-99) , 
6, 0.571687, 0, 0, 0.475075,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.37168,-99) , 
5, 143.301, 1, 0, 0.453125,-99) , 
0, 0.897601, 0, 0, 0.506188,-99)    );
  // itree = 39
  fBoostWeights.push_back(0.0390369);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 310.758, 0, 1, 0.557729,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.636734,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.496887,-99) , 
2, 518.192, 0, 0, 0.504938,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.505355,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.470379,-99) , 
6, -0.343018, 1, 0, 0.48424,-99) , 
0, 2.5432, 1, 0, 0.496096,-99) , 
3, 0.0810341, 0, 0, 0.502939,-99)    );
  // itree = 40
  fBoostWeights.push_back(0.0452853);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.615427,-99) , 
NN(
NN(
0, 
0, 
-1, 433.277, 0, 1, 0.519365,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.511602,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.471294,-99) , 
7, 0.897332, 0, 0, 0.489928,-99) , 
4, 179.307, 0, 0, 0.511152,-99) , 
5, 283.739, 0, 0, 0.514272,-99)    );
  // itree = 41
  fBoostWeights.push_back(0.042954);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.58315,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.534908,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.470387,-99) , 
7, 1.34234, 1, 0, 0.51177,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.503001,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.45651,-99) , 
2, 229.112, 0, 0, 0.492294,-99) , 
5, 81.1306, 1, 0, 0.49863,-99) , 
5, 267.908, 0, 0, 0.501808,-99)    );
  // itree = 42
  fBoostWeights.push_back(0.0390881);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.567959,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.564681,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.494393,-99) , 
1, 1.0472, 0, 0, 0.50555,-99) , 
NN(
0, 
0, 
-1, 1.34554, 1, -1, 0.474682,-99) , 
2, 208.429, 0, 0, 0.498943,-99) , 
4, 416.971, 0, 0, 0.502122,-99)    );
  // itree = 43
  fBoostWeights.push_back(0.02195);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.57985,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.545426,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.4976,-99) , 
5, 122.658, 1, 0, 0.526018,-99) , 
NN(
0, 
0, 
-1, 84.5098, 0, -1, 0.495082,-99) , 
1, 0.149604, 1, 0, 0.499537,-99) , 
5, 267.993, 0, 0, 0.502606,-99)    );
  // itree = 44
  fBoostWeights.push_back(0.0414791);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 365.226, 0, 1, 0.542577,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.520239,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.490834,-99) , 
1, 1.19676, 0, 0, 0.498371,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.517836,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.443468,-99) , 
4, 134.37, 0, 0, 0.463984,-99) , 
4, 148.324, 0, 0, 0.492389,-99) , 
3, 0.0808255, 0, 0, 0.498153,-99)    );
  // itree = 45
  fBoostWeights.push_back(0.0352215);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.578275,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.511487,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.453379,-99) , 
6, 1.70286, 1, 0, 0.50833,-99) , 
NN(
0, 
0, 
-1, 112.236, 1, -1, 0.469882,-99) , 
6, -1.25704, 0, 0, 0.504209,-99) , 
5, 267.994, 0, 0, 0.507044,-99)    );
  // itree = 46
  fBoostWeights.push_back(0.0389171);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.57075,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.528013,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.439632,-99) , 
4, 80.4561, 0, 0, 0.520658,-99) , 
NN(
0, 
0, 
-1, 242.624, 0, -1, 0.489348,-99) , 
4, 186.233, 1, 0, 0.499924,-99) , 
5, 267.908, 0, 0, 0.502611,-99)    );
  // itree = 47
  fBoostWeights.push_back(0.0333394);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 158.957, 0, 1, 0.549991,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.517854,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.49667,-99) , 
7, 0.897539, 0, 0, 0.509349,-99) , 
NN(
0, 
0, 
-1, 146.374, 0, -1, 0.479582,-99) , 
6, 1.02828, 1, 0, 0.50433,-99) , 
3, 0.110155, 0, 0, 0.50836,-99)    );
  // itree = 48
  fBoostWeights.push_back(0.0308836);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 327.099, 0, 1, 0.544401,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.510768,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.49038,-99) , 
3, -0.303942, 1, 0, 0.496944,-99) , 
NN(
0, 
0, 
-1, -0.466517, 0, -1, 0.45306,-99) , 
1, 2.84239, 1, 0, 0.493709,-99) , 
3, 0.120046, 0, 0, 0.498065,-99)    );
  // itree = 49
  fBoostWeights.push_back(0.0351809);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.603672,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.518009,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.484253,-99) , 
2, 468.89, 1, 0, 0.51123,-99) , 
5, 213.434, 0, 0, 0.523583,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.537189,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.497371,-99) , 
3, -0.611538, 1, 0, 0.500647,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.530829,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.435145,-99) , 
2, 162.197, 1, 0, 0.46923,-99) , 
0, 0.748005, 0, 0, 0.495801,-99) , 
7, 1.9445, 0, 0, 0.504016,-99)    );
  // itree = 50
  fBoostWeights.push_back(0.0288962);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 2.84286, 1, 1, 0.549334,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.519009,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.495761,-99) , 
1, 0.4488, 1, 0, 0.504278,-99) , 
2, 597.729, 0, 0, 0.507719,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.44899,-99) , 
6, 1.7139, 1, 0, 0.505019,-99)    );
  // itree = 51
  fBoostWeights.push_back(0.0201243);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.550753,-99) , 
NN(
NN(
0, 
0, 
-1, 2.99194, 0, 1, 0.504296,-99) , 
NN(
0, 
0, 
-1, 1.49598, 1, -1, 0.446442,-99) , 
4, 120.636, 0, 0, 0.499742,-99) , 
4, 421.697, 0, 0, 0.502004,-99)    );
  // itree = 52
  fBoostWeights.push_back(0.0129994);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.574824,-99) , 
NN(
NN(
0, 
0, 
-1, 262.326, 0, 1, 0.502464,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.46085,-99) , 
6, 1.71404, 1, 0, 0.500465,-99) , 
4, 448.537, 0, 0, 0.50286,-99)    );
  // itree = 53
  fBoostWeights.push_back(0.0296258);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.565169,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.58584,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.499084,-99) , 
2, 500.026, 0, 0, 0.504466,-99) , 
NN(
0, 
0, 
-1, 60.3772, 0, -1, 0.478542,-99) , 
0, 2.54319, 1, 0, 0.493223,-99) , 
5, 267.907, 0, 0, 0.49597,-99)    );
  // itree = 54
  fBoostWeights.push_back(0.0379852);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.527196,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.49373,-99) , 
0, 0.897688, 0, 0, 0.522457,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.504829,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.460694,-99) , 
7, 0.29911, 0, 0, 0.500376,-99) , 
6, 0.56061, 1, 0, 0.51272,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.54294,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.491381,-99) , 
4, 303.789, 0, 0, 0.504348,-99) , 
NN(
0, 
0, 
-1, 93.6421, 1, -1, 0.473064,-99) , 
7, 1.64548, 0, 0, 0.485096,-99) , 
6, -0.571322, 0, 0, 0.504557,-99)    );
  // itree = 55
  fBoostWeights.push_back(0.0370136);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, -0.047769, 0, 1, 0.549813,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.510514,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.454502,-99) , 
6, -1.71402, 0, 0, 0.508228,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.521627,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.387816,-99) , 
1, 1.34635, 1, 0, 0.467978,-99) , 
4, 124.568, 0, 0, 0.504565,-99) , 
2, 623.098, 0, 0, 0.50775,-99)    );
  // itree = 56
  fBoostWeights.push_back(0.0507103);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.661452,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.523767,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.472903,-99) , 
2, 200.634, 0, 0, 0.500519,-99) , 
2, 427.12, 0, 0, 0.510744,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.563125,-99) , 
NN(
0, 
0, 
-1, 1.48521, 1, -1, 0.48309,-99) , 
5, 258.892, 0, 0, 0.487418,-99) , 
1, 0.747979, 0, 0, 0.496928,-99)    );
  // itree = 57
  fBoostWeights.push_back(0.0431765);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.642498,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.528051,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.475028,-99) , 
7, 1.49581, 0, 0, 0.503207,-99) , 
1, 0.598349, 0, 0, 0.524642,-99) , 
NN(
NN(
0, 
0, 
-1, 0.363314, 0, 1, 0.515807,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.546385,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.485878,-99) , 
2, 139.21, 1, 0, 0.488941,-99) , 
1, 0.448826, 1, 0, 0.497472,-99) , 
2, 453.173, 0, 0, 0.502972,-99)    );
  // itree = 58
  fBoostWeights.push_back(0.0253299);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, -0.114548, 1, 1, 0.550099,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.558999,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.50409,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.477577,-99) , 
6, 0.799945, 1, 0, 0.497982,-99) , 
4, 441.038, 0, 0, 0.50017,-99) , 
7, 0.149597, 1, 0, 0.503333,-99)    );
  // itree = 59
  fBoostWeights.push_back(0.0359356);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.619066,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.477513,-99) , 
0, 2.69302, 1, 0, 0.529925,-99) , 
NN(
NN(
0, 
0, 
-1, 0.897581, 0, 1, 0.512148,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.52582,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.485792,-99) , 
7, 1.94417, 0, 0, 0.494287,-99) , 
2, 341.135, 0, 0, 0.501047,-99) , 
2, 620.648, 0, 0, 0.503049,-99)    );
  // itree = 60
  fBoostWeights.push_back(0.0391688);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.606565,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.606297,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.497632,-99) , 
2, 136.087, 1, 0, 0.505693,-99) , 
2, 418.278, 0, 0, 0.514611,-99) , 
NN(
NN(
0, 
0, 
-1, 2.71413, 1, 1, 0.53932,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.560209,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.484085,-99) , 
5, 267.995, 0, 0, 0.487716,-99) , 
7, 0.299199, 1, 0, 0.493093,-99) , 
0, 2.24399, 1, 0, 0.501914,-99)    );
  // itree = 61
  fBoostWeights.push_back(0.0379545);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.638932,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.50756,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.437292,-99) , 
6, 1.02737, 1, 0, 0.497212,-99) , 
2, 298.137, 0, 0, 0.52043,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.567426,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.498552,-99) , 
5, 213.497, 0, 0, 0.505859,-99) , 
NN(
0, 
0, 
-1, 142.751, 1, -1, 0.479388,-99) , 
7, 0.89748, 0, 0, 0.497975,-99) , 
1, 1.0472, 0, 0, 0.504482,-99)    );
  // itree = 62
  fBoostWeights.push_back(0.0224375);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.572793,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.545606,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.49846,-99) , 
1, 1.94417, 0, 0, 0.502187,-99) , 
5, 267.994, 0, 0, 0.504918,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.518352,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.480849,-99) , 
2, 166.867, 1, 0, 0.49534,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.430431,-99) , 
5, 138.721, 1, 0, 0.480882,-99) , 
0, 1.04721, 0, 0, 0.501101,-99)    );
  // itree = 63
  fBoostWeights.push_back(0.0486055);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.648474,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.533643,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.467136,-99) , 
7, 0.598412, 0, 0, 0.520338,-99) , 
1, 0.597779, 0, 0, 0.540993,-99) , 
NN(
NN(
0, 
0, 
-1, 0.448741, 1, 1, 0.516525,-99) , 
NN(
0, 
0, 
-1, 126.43, 0, -1, 0.4802,-99) , 
1, 2.39359, 1, 0, 0.509726,-99) , 
2, 453.173, 0, 0, 0.516131,-99)    );
  // itree = 64
  fBoostWeights.push_back(0.0458275);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.661097,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.558866,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.484904,-99) , 
2, 154.858, 1, 0, 0.504947,-99) , 
2, 290.811, 0, 0, 0.531488,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.514195,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.491756,-99) , 
2, 408.805, 1, 0, 0.506738,-99) , 
NN(
0, 
0, 
-1, -1.79024, 1, -1, 0.465385,-99) , 
6, -1.48544, 0, 0, 0.503638,-99) , 
1, 1.64558, 0, 0, 0.510628,-99)    );
  // itree = 65
  fBoostWeights.push_back(0.0263316);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.584831,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.47061,-99) , 
7, 0.59603, 0, 0, 0.539881,-99) , 
NN(
0, 
0, 
-1, 0.448776, 1, 1, 0.506103,-99) , 
3, -0.503093, 1, 0, 0.509504,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.443476,-99) , 
4, 84.5098, 0, 0, 0.507539,-99)    );
  // itree = 66
  fBoostWeights.push_back(0.0466282);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.972352, 0, 1, 0.548357,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.468287,-99) , 
7, 0.297773, 0, 0, 0.530235,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.548414,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.441433,-99) , 
7, 0.897583, 0, 0, 0.522339,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.518097,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.489011,-99) , 
7, 0.747779, 1, 0, 0.496904,-99) , 
4, 311.727, 0, 0, 0.501494,-99) , 
1, 2.54318, 0, 0, 0.505578,-99)    );
  // itree = 67
  fBoostWeights.push_back(0.0368327);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.557132,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.457812,-99) , 
5, 143.302, 1, 0, 0.53521,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.44006,-99) , 
4, 127.83, 0, 0, 0.520371,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.563121,-99) , 
NN(
0, 
0, 
-1, 1.94482, 0, -1, 0.493652,-99) , 
4, 441.038, 0, 0, 0.496375,-99) , 
0, 1.3464, 1, 0, 0.501481,-99)    );
  // itree = 68
  fBoostWeights.push_back(0.0351185);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.595064,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.535638,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.484039,-99) , 
5, 84.926, 1, 0, 0.505789,-99) , 
0, 0.653115, 0, 0, 0.542529,-99) , 
NN(
NN(
0, 
0, 
-1, 2.8429, 1, 1, 0.538789,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.508218,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.485588,-99) , 
6, 0.342648, 1, 0, 0.499882,-99) , 
2, 599.917, 0, 0, 0.503269,-99) , 
1, 2.69276, 0, 0, 0.507726,-99)    );
  // itree = 69
  fBoostWeights.push_back(0.0343831);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.553146,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.488738,-99) , 
7, 1.64534, 0, 0, 0.533041,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.531203,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.494715,-99) , 
2, 232.725, 0, 0, 0.513744,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.503008,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.468553,-99) , 
4, 309.986, 1, 0, 0.496538,-99) , 
0, 2.54319, 1, 0, 0.506238,-99) , 
3, 0.0808255, 0, 0, 0.509292,-99)    );
  // itree = 70
  fBoostWeights.push_back(0.0341604);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 213.506, 0, 1, 0.528427,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.508526,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.483455,-99) , 
0, 2.54318, 1, 0, 0.497671,-99) , 
3, 0.0205082, 0, 0, 0.50359,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.446997,-99) , 
4, 105.598, 0, 0, 0.500728,-99)    );
  // itree = 71
  fBoostWeights.push_back(0.0259143);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 182.675, 1, 1, 0.550336,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.533339,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.49947,-99) , 
1, 1.04714, 0, 0, 0.50831,-99) , 
NN(
0, 
0, 
-1, 0.897542, 0, -1, 0.487464,-99) , 
6, -0.342917, 0, 0, 0.500451,-99) , 
0, 0.448807, 1, 0, 0.503652,-99)    );
  // itree = 72
  fBoostWeights.push_back(0.0301888);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.293629, 0, 1, 0.536402,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.528264,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.497405,-99) , 
4, 300.111, 0, 0, 0.503864,-99) , 
7, 0.299168, 1, 0, 0.50687,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.551413,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.466866,-99) , 
3, -0.28931, 0, 0, 0.490927,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.438232,-99) , 
4, 251.735, 1, 0, 0.478569,-99) , 
0, 0.897632, 0, 0, 0.503041,-99)    );
  // itree = 73
  fBoostWeights.push_back(0.0502954);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.622868,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.529839,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.467449,-99) , 
6, -0.571569, 0, 0, 0.511332,-99) , 
0, 2.2443, 1, 0, 0.526289,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.511824,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.459166,-99) , 
4, 125.557, 0, 0, 0.506677,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.559056,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.441602,-99) , 
2, 137.287, 1, 0, 0.470712,-99) , 
2, 174.658, 0, 0, 0.501779,-99) , 
2, 453.694, 0, 0, 0.506697,-99)    );
  // itree = 74
  fBoostWeights.push_back(0.0383234);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 2.57848, 1, 1, 0.548602,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.521255,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.491826,-99) , 
7, 1.64551, 0, 0, 0.508655,-99) , 
3, -0.320168, 1, 0, 0.519341,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.550902,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.532156,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.488018,-99) , 
2, 150.289, 1, 0, 0.491767,-99) , 
2, 506.829, 0, 0, 0.494675,-99) , 
1, 0.448804, 1, 0, 0.50468,-99)    );
  // itree = 75
  fBoostWeights.push_back(0.0184374);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.548459,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.538306,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.496151,-99) , 
1, 2.69264, 0, 0, 0.498428,-99) , 
5, 267.994, 0, 0, 0.50031,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.502391,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.421395,-99) , 
0, 0.398932, 1, 0, 0.471984,-99) , 
0, 0.598405, 0, 0, 0.498037,-99)    );
  // itree = 76
  fBoostWeights.push_back(0.043318);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 69.8067, 0, 1, 0.527617,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.527269,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.442212,-99) , 
1, 0.748026, 0, 0, 0.485627,-99) , 
6, -1.25715, 0, 0, 0.522669,-99) , 
NN(
NN(
0, 
0, 
-1, 1.79705, 1, 1, 0.510008,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.507515,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.422168,-99) , 
5, 143.303, 1, 0, 0.467921,-99) , 
7, 0.598379, 0, 0, 0.50239,-99) , 
4, 210.221, 1, 0, 0.511428,-99)    );
  // itree = 77
  fBoostWeights.push_back(0.0373669);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 194.664, 0, 1, 0.536719,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.537282,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.492192,-99) , 
7, 0.448523, 1, 0, 0.499828,-99) , 
0, 1.496, 1, 0, 0.510583,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.52746,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.489662,-99) , 
1, 1.19673, 0, 0, 0.494863,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.430676,-99) , 
0, 0.748002, 0, 0, 0.489288,-99) , 
5, 104.499, 1, 0, 0.499762,-99)    );
  // itree = 78
  fBoostWeights.push_back(0.030071);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, -0.609808, 1, 1, 0.513821,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.503534,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.426818,-99) , 
5, 138.719, 1, 0, 0.486617,-99) , 
0, 0.897604, 0, 0, 0.510133,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.512317,-99) , 
NN(
0, 
0, 
-1, 1.77369, 0, -1, 0.479904,-99) , 
7, 0.747918, 1, 0, 0.489454,-99) , 
6, -1.02861, 0, 0, 0.506854,-99)    );
  // itree = 79
  fBoostWeights.push_back(0.0343287);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 2.39356, 0, 1, 0.508856,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.515179,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.454576,-99) , 
7, 1.4457, 1, 0, 0.499251,-99) , 
NN(
0, 
0, 
-1, 1.6456, 0, -1, 0.460904,-99) , 
7, 0.598227, 0, 0, 0.484721,-99) , 
3, -0.227901, 0, 0, 0.498997,-99)    );
  // itree = 80
  fBoostWeights.push_back(0.044314);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.553926,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.490628,-99) , 
7, 0.106842, 0, 0, 0.540688,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.442166,-99) , 
5, 143.306, 1, 0, 0.518406,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.565022,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.49975,-99) , 
3, -0.317228, 1, 0, 0.516034,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.522905,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.483968,-99) , 
1, 2.71415, 0, 0, 0.487417,-99) , 
1, 0.149616, 1, 0, 0.491731,-99) , 
7, 0.448743, 1, 0, 0.496496,-99)    );
  // itree = 81
  fBoostWeights.push_back(0.0484237);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.584296,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.546151,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.463326,-99) , 
0, 2.81266, 0, 0, 0.497263,-99) , 
1, 0.897411, 0, 0, 0.528238,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.526124,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.496523,-99) , 
2, 262.421, 1, 0, 0.50311,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.600557,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.45488,-99) , 
2, 290.954, 0, 0, 0.478,-99) , 
1, 1.34638, 1, 0, 0.496765,-99) , 
6, -1.25689, 1, 0, 0.500426,-99)    );
  // itree = 82
  fBoostWeights.push_back(0.039579);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.571915,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.483345,-99) , 
7, 1.28213, 0, 0, 0.53122,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.508829,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.4591,-99) , 
4, 100.968, 0, 0, 0.505813,-99) , 
5, 158.955, 0, 0, 0.511165,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.444534,-99) , 
7, 2.69242, 1, 0, 0.508521,-99)    );
  // itree = 83
  fBoostWeights.push_back(0.0246584);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 158.966, 1, 1, 0.536259,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.535081,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.497975,-99) , 
1, 1.64559, 0, 0, 0.503478,-99) , 
NN(
0, 
0, 
-1, 138.729, 1, -1, 0.471337,-99) , 
2, 188.525, 0, 0, 0.498152,-99) , 
2, 620.512, 0, 0, 0.500813,-99)    );
  // itree = 84
  fBoostWeights.push_back(0.0234656);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 704.812, 0, 1, 0.510628,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.4655,-99) , 
6, 1.71406, 1, 0, 0.508543,-99)    );
  // itree = 85
  fBoostWeights.push_back(0.0348947);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.53246,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.498061,-99) , 
3, -0.201785, 1, 0, 0.511872,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.512684,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.485039,-99) , 
2, 426.353, 0, 0, 0.492127,-99) , 
6, 0.571283, 0, 0, 0.498227,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.506619,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.461207,-99) , 
1, 1.79517, 0, 0, 0.479153,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.438424,-99) , 
4, 104.986, 0, 0, 0.462725,-99) , 
4, 137.451, 0, 0, 0.493979,-99)    );
  // itree = 86
  fBoostWeights.push_back(0.0269668);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 2.0301, 0, 1, 0.508759,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.546357,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.484243,-99) , 
0, 0.339327, 1, 0, 0.498718,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.40551,-99) , 
5, 143.301, 1, 0, 0.482708,-99) , 
1, 2.24398, 1, 0, 0.504105,-99)    );
  // itree = 87
  fBoostWeights.push_back(0.036248);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.609647,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.51859,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.476398,-99) , 
7, 2.39327, 1, 0, 0.507533,-99) , 
0, 2.2443, 1, 0, 0.521883,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.504496,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.461929,-99) , 
2, 174.655, 0, 0, 0.499724,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.504005,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.461478,-99) , 
2, 211.812, 1, 0, 0.4779,-99) , 
4, 187.601, 0, 0, 0.491691,-99) , 
2, 453.694, 0, 0, 0.497761,-99)    );
  // itree = 88
  fBoostWeights.push_back(0.0406643);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.142466, 0, 1, 0.560443,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.52156,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.470456,-99) , 
1, 2.69283, 0, 0, 0.497315,-99) , 
0, 2.3936, 0, 0, 0.529031,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.598341,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.496123,-99) , 
1, 0.598284, 0, 0, 0.511705,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.50463,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.477567,-99) , 
7, 1.92316, 0, 0, 0.485807,-99) , 
2, 445.366, 0, 0, 0.491461,-99) , 
7, 0.299179, 1, 0, 0.495896,-99)    );
  // itree = 89
  fBoostWeights.push_back(0.0455845);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.544311,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.481496,-99) , 
7, 2.57151, 1, 0, 0.531841,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.587371,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.487685,-99) , 
0, 0.900678, 1, 0, 0.493153,-99) , 
5, 158.955, 0, 0, 0.502365,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.511767,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.476601,-99) , 
3, -0.387834, 0, 0, 0.497071,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.409835,-99) , 
5, 189.748, 1, 0, 0.4873,-99) , 
7, 0.74795, 0, 0, 0.497735,-99)    );
  // itree = 90
  fBoostWeights.push_back(0.0434741);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, -0.559885, 1, 1, 0.516202,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.43513,-99) , 
0, 0.598405, 0, 0, 0.507378,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.546056,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.472464,-99) , 
2, 176.764, 0, 0, 0.519638,-99) , 
NN(
0, 
0, 
-1, 0.89751, 0, -1, 0.483292,-99) , 
1, 1.04719, 0, 0, 0.491574,-99) , 
4, 204.832, 1, 0, 0.498093,-99)    );
  // itree = 91
  fBoostWeights.push_back(0.0320378);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 226.611, 0, 1, 0.509538,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.451571,-99) , 
6, 1.71375, 1, 0, 0.50671,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.547806,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.476098,-99) , 
5, 96.6506, 0, 0, 0.514028,-99) , 
NN(
0, 
0, 
-1, -0.571368, 1, -1, 0.470958,-99) , 
0, 0.448841, 1, 0, 0.481441,-99) , 
7, 0.598325, 0, 0, 0.500757,-99)    );
  // itree = 92
  fBoostWeights.push_back(0.0360304);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.548738,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.487208,-99) , 
2, 198.027, 0, 0, 0.530439,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.544501,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.49636,-99) , 
5, 228.123, 0, 0, 0.500638,-99) , 
1, 0.74776, 0, 0, 0.509314,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.537158,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.491806,-99) , 
0, 0.349041, 1, 0, 0.504277,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.439702,-99) , 
5, 131.015, 1, 0, 0.488125,-99) , 
0, 1.0472, 0, 0, 0.505882,-99)    );
  // itree = 93
  fBoostWeights.push_back(0.049897);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.592914,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.526785,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.489709,-99) , 
1, 0.22789, 1, 0, 0.502549,-99) , 
1, 1.19679, 0, 0, 0.510143,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.52489,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.479507,-99) , 
1, 1.3465, 1, 0, 0.501639,-99) , 
NN(
0, 
0, 
-1, 308.121, 1, -1, 0.440998,-99) , 
4, 256.515, 1, 0, 0.491213,-99) , 
2, 270.18, 0, 0, 0.502888,-99)    );
  // itree = 94
  fBoostWeights.push_back(0.0304825);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, -0.375402, 1, 1, 0.511597,-99) , 
NN(
0, 
0, 
-1, 209.333, 0, -1, 0.464073,-99) , 
6, -1.48551, 0, 0, 0.508247,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.500692,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.424154,-99) , 
6, 0.116073, 0, 0, 0.462571,-99) , 
0, 0.598434, 0, 0, 0.504703,-99)    );
  // itree = 95
  fBoostWeights.push_back(0.0263724);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.575853,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.499305,-99) , 
2, 240.909, 1, 0, 0.532812,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.519404,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.475044,-99) , 
7, 0.432057, 0, 0, 0.510652,-99) , 
NN(
0, 
0, 
-1, 1.14678, 0, -1, 0.49168,-99) , 
3, -0.323084, 1, 0, 0.497221,-99) , 
7, 0.14959, 1, 0, 0.499361,-99)    );
  // itree = 96
  fBoostWeights.push_back(0.0239975);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.582185,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.528411,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.497848,-99) , 
5, 175.105, 0, 0, 0.502853,-99) , 
4, 433.604, 0, 0, 0.505832,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.505636,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.460444,-99) , 
0, 2.84238, 1, 0, 0.497147,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.432968,-99) , 
5, 189.952, 1, 0, 0.490017,-99) , 
7, 0.747951, 0, 0, 0.500992,-99)    );
  // itree = 97
  fBoostWeights.push_back(0.0257727);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.551583,-99) , 
NN(
NN(
0, 
0, 
-1, 404.043, 0, 1, 0.510828,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.501559,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.42796,-99) , 
4, 300.409, 1, 0, 0.490234,-99) , 
7, 0.747871, 0, 0, 0.504853,-99) , 
1, 2.99198, 0, 0, 0.506706,-99)    );
  // itree = 98
  fBoostWeights.push_back(0.0329256);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.559491,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.551162,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.482487,-99) , 
3, -0.352249, 0, 0, 0.516895,-99) , 
2, 199.82, 0, 0, 0.535215,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.532868,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.480169,-99) , 
5, 143.184, 1, 0, 0.520118,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.550782,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.493654,-99) , 
4, 420.111, 0, 0, 0.496226,-99) , 
7, 0.598379, 1, 0, 0.501212,-99) , 
1, 2.69278, 0, 0, 0.505047,-99)    );
  // itree = 99
  fBoostWeights.push_back(0.0341833);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.514002,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.481767,-99) , 
0, 0.748001, 0, 0, 0.510391,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.510582,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.483263,-99) , 
7, 0.747901, 1, 0, 0.491562,-99) , 
6, -0.876203, 0, 0, 0.505406,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.541079,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.490033,-99) , 
6, 1.63768, 0, 0, 0.502003,-99) , 
NN(
0, 
0, 
-1, 227.056, 0, -1, 0.465417,-99) , 
7, 1.34603, 1, 0, 0.484657,-99) , 
6, 0.799833, 1, 0, 0.500634,-99)    );
   return;
};
 
// Clean up
inline void ReadBDT_100_25_05_20::Clear() 
{
   for (unsigned int itree=0; itree<fForest.size(); itree++) { 
      delete fForest[itree]; 
   }
}
   inline double ReadBDT_100_25_05_20::GetMvaValue( const std::vector<double>& inputValues ) const
   {
      // classifier response value
      double retval = 0;

      // classifier response, sanity check first
      if (!IsStatusClean()) {
         std::cout << "Problem in class \"" << fClassName << "\": cannot return classifier response"
                   << " because status is dirty" << std::endl;
         retval = 0;
      }
      else {
         if (IsNormalised()) {
            // normalise variables
            std::vector<double> iV;
            iV.reserve(inputValues.size());
            int ivar = 0;
            for (std::vector<double>::const_iterator varIt = inputValues.begin();
                 varIt != inputValues.end(); varIt++, ivar++) {
               iV.push_back(NormVariable( *varIt, fVmin[ivar], fVmax[ivar] ));
            }
            retval = GetMvaValue__( iV );
         }
         else {
            retval = GetMvaValue__( inputValues );
         }
      }

      return retval;
   }
