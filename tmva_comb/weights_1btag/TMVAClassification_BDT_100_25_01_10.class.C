// Class: ReadBDT_100_25_01_10
// Automatically generated by MethodBase::MakeClass
//

/* configuration options =====================================================

#GEN -*-*-*-*-*-*-*-*-*-*-*- general info -*-*-*-*-*-*-*-*-*-*-*-

Method         : BDT::BDT_100_25_01_10
TMVA Release   : 4.2.1         [262657]
ROOT Release   : 6.06/01       [394753]
Creator        : matthies
Date           : Tue Sep 18 22:38:44 2018
Host           : Linux vocms0301.cern.ch 2.6.32-642.4.2.el6.x86_64 #1 SMP Wed Aug 24 09:19:54 CEST 2016 x86_64 x86_64 x86_64 GNU/Linux
Dir            : /nfs/dust/cms/user/matthies/Analysis_80x_v5/CMSSW_8_0_24_patch1/src/UHH2/BoostedSingleTop/tmva_comb
Training events: 274422
Analysis type  : [Classification]


#OPT -*-*-*-*-*-*-*-*-*-*-*-*- options -*-*-*-*-*-*-*-*-*-*-*-*-

# Set by User:
V: "False" [Verbose output (short form of "VerbosityLevel" below - overrides the latter one)]
H: "False" [Print method-specific help message]
NTrees: "100" [Number of trees in the forest]
MaxDepth: "3" [Max depth of the decision tree allowed]
MinNodeSize: "2.5%" [Minimum percentage of training events required in a leaf node (default: Classification: 5%, Regression: 0.2%)]
nCuts: "10" [Number of grid points in variable range used in finding optimal cut in node splitting]
BoostType: "AdaBoost" [Boosting type for the trees in the forest (note: AdaCost is still experimental)]
UseBaggedBoost: "True" [Use only a random subsample of all events for growing the trees in each boost iteration.]
AdaBoostBeta: "1.000000e-01" [Learning rate  for AdaBoost algorithm]
BaggedSampleFraction: "5.000000e-01" [Relative size of bagged event sample to original size of the data sample (used whenever bagging is used (i.e. UseBaggedBoost, Bagging,)]
SeparationType: "giniindex" [Separation criterion for node splitting]
# Default:
VerbosityLevel: "Default" [Verbosity level]
VarTransform: "None" [List of variable transformations performed before training, e.g., "D_Background,P_Signal,G,N_AllClasses" for: "Decorrelation, PCA-transformation, Gaussianisation, Normalisation, each for the given class of events ('AllClasses' denotes all events of all classes, if no class indication is given, 'All' is assumed)"]
CreateMVAPdfs: "False" [Create PDFs for classifier outputs (signal and background)]
IgnoreNegWeightsInTraining: "False" [Events with negative weights are ignored in the training (but are included for testing and performance evaluation)]
AdaBoostR2Loss: "quadratic" [Type of Loss function in AdaBoostR2]
Shrinkage: "1.000000e+00" [Learning rate for GradBoost algorithm]
UseRandomisedTrees: "False" [Determine at each node splitting the cut variable only as the best out of a random subset of variables (like in RandomForests)]
UseNvars: "3" [Size of the subset of variables used with RandomisedTree option]
UsePoissonNvars: "True" [Interpret "UseNvars" not as fixed number but as mean of a Possion distribution in each split with RandomisedTree option]
UseYesNoLeaf: "True" [Use Sig or Bkg categories, or the purity=S/(S+B) as classification of the leaf node -> Real-AdaBoost]
NegWeightTreatment: "inverseboostnegweights" [How to treat events with negative weights in the BDT training (particular the boosting) : IgnoreInTraining;  Boost With inverse boostweight; Pair events with negative and positive weights in traning sample and *annihilate* them (experimental!)]
Css: "1.000000e+00" [AdaCost: cost of true signal selected signal]
Cts_sb: "1.000000e+00" [AdaCost: cost of true signal selected bkg]
Ctb_ss: "1.000000e+00" [AdaCost: cost of true bkg    selected signal]
Cbb: "1.000000e+00" [AdaCost: cost of true bkg    selected bkg ]
NodePurityLimit: "5.000000e-01" [In boosting/pruning, nodes with purity > NodePurityLimit are signal; background otherwise.]
DoBoostMonitor: "False" [Create control plot with ROC integral vs tree number]
UseFisherCuts: "False" [Use multivariate splits using the Fisher criterion]
MinLinCorrForFisher: "8.000000e-01" [The minimum linear correlation between two variables demanded for use in Fisher criterion in node splitting]
UseExclusiveVars: "False" [Variables already used in fisher criterion are not anymore analysed individually for node splitting]
DoPreselection: "False" [and and apply automatic pre-selection for 100% efficient signal (bkg) cuts prior to training]
SigToBkgFraction: "1.000000e+00" [Sig to Bkg ratio used in Training (similar to NodePurityLimit, which cannot be used in real adaboost]
PruneMethod: "nopruning" [Note: for BDTs use small trees (e.g.MaxDepth=3) and NoPruning:  Pruning: Method used for pruning (removal) of statistically insignificant branches ]
PruneStrength: "0.000000e+00" [Pruning strength]
PruningValFraction: "5.000000e-01" [Fraction of events to use for optimizing automatic pruning.]
nEventsMin: "0" [deprecated: Use MinNodeSize (in % of training events) instead]
UseBaggedGrad: "False" [deprecated: Use *UseBaggedBoost* instead:  Use only a random subsample of all events for growing the trees in each iteration.]
GradBaggingFraction: "5.000000e-01" [deprecated: Use *BaggedSampleFraction* instead: Defines the fraction of events to be used in each iteration, e.g. when UseBaggedGrad=kTRUE. ]
UseNTrainEvents: "0" [deprecated: Use *BaggedSampleFraction* instead: Number of randomly picked training events used in randomised (and bagged) trees]
NNodesMax: "0" [deprecated: Use MaxDepth instead to limit the tree size]
##


#VAR -*-*-*-*-*-*-*-*-*-*-*-* variables *-*-*-*-*-*-*-*-*-*-*-*-

NVar 8
tmva_deltaphi_bottomlepton    tmva_deltaphi_bottomlepton    tmva_deltaphi_bottomlepton    #Delta#phi(l,b)               rad                               'F'    [5.96046447754e-06,3.14158797264]
tmva_deltaphi_bottomtoptag    tmva_deltaphi_bottomtoptag    tmva_deltaphi_bottomtoptag    #Delta#phi(t,b)               rad                               'F'    [2.80514359474e-06,3.14159035683]
tmva_pseudotop_mass           tmva_pseudotop_mass           tmva_pseudotop_mass           l#nub mass                    GeV                               'F'    [87.0424880981,5391.02001953]
tmva_ptbalance                tmva_ptbalance                tmva_ptbalance                pT balance                                                      'F'    [-0.99552065134,3.99204134941]
tmva_wass_pt                  tmva_wass_pt                  tmva_wass_pt                  asso. W pT                    GeV                               'F'    [1.03412163258,2188.19360352]
tmva_lepton_pt                tmva_lepton_pt                tmva_lepton_pt                lepton pT                     GeV                               'F'    [50.0013122559,1194.46325684]
tmva_lepton_eta               tmva_lepton_eta               tmva_lepton_eta               lepton #eta                                                     'F'    [-2.39999055862,2.39999628067]
tmva_deltaphi_leptonnextjet   tmva_deltaphi_leptonnextjet   tmva_deltaphi_leptonnextjet   #Delta#phi(l,jet)             rad                               'F'    [6.31809234619e-06,3.14152240753]
NSpec 0


============================================================================ */

#include <vector>
#include <cmath>
#include <string>
#include <iostream>

#define NN new BDT_100_25_01_10Node
   
#ifndef BDT_100_25_01_10Node__def
#define BDT_100_25_01_10Node__def
   
class BDT_100_25_01_10Node {
   
public:
   
   // constructor of an essentially "empty" node floating in space
   BDT_100_25_01_10Node ( BDT_100_25_01_10Node* left,BDT_100_25_01_10Node* right,
                          int selector, double cutValue, bool cutType, 
                          int nodeType, double purity, double response ) :
   fLeft         ( left         ),
   fRight        ( right        ),
   fSelector     ( selector     ),
   fCutValue     ( cutValue     ),
   fCutType      ( cutType      ),
   fNodeType     ( nodeType     ),
   fPurity       ( purity       ),
   fResponse     ( response     ){
   }

   virtual ~BDT_100_25_01_10Node();

   // test event if it decends the tree at this node to the right
   virtual bool GoesRight( const std::vector<double>& inputValues ) const;
   BDT_100_25_01_10Node* GetRight( void )  {return fRight; };

   // test event if it decends the tree at this node to the left 
   virtual bool GoesLeft ( const std::vector<double>& inputValues ) const;
   BDT_100_25_01_10Node* GetLeft( void ) { return fLeft; };   

   // return  S/(S+B) (purity) at this node (from  training)

   double GetPurity( void ) const { return fPurity; } 
   // return the node type
   int    GetNodeType( void ) const { return fNodeType; }
   double GetResponse(void) const {return fResponse;}

private:

   BDT_100_25_01_10Node*   fLeft;     // pointer to the left daughter node
   BDT_100_25_01_10Node*   fRight;    // pointer to the right daughter node
   int                     fSelector; // index of variable used in node selection (decision tree)   
   double                  fCutValue; // cut value appplied on this node to discriminate bkg against sig
   bool                    fCutType;  // true: if event variable > cutValue ==> signal , false otherwise
   int                     fNodeType; // Type of node: -1 == Bkg-leaf, 1 == Signal-leaf, 0 = internal 
   double                  fPurity;   // Purity of node from training
   double                  fResponse; // Regression response value of node
}; 
   
//_______________________________________________________________________
   BDT_100_25_01_10Node::~BDT_100_25_01_10Node()
{
   if (fLeft  != NULL) delete fLeft;
   if (fRight != NULL) delete fRight;
}; 
   
//_______________________________________________________________________
bool BDT_100_25_01_10Node::GoesRight( const std::vector<double>& inputValues ) const
{
   // test event if it decends the tree at this node to the right
   bool result;
     result = (inputValues[fSelector] > fCutValue );
   if (fCutType == true) return result; //the cuts are selecting Signal ;
   else return !result;
}
   
//_______________________________________________________________________
bool BDT_100_25_01_10Node::GoesLeft( const std::vector<double>& inputValues ) const
{
   // test event if it decends the tree at this node to the left
   if (!this->GoesRight(inputValues)) return true;
   else return false;
}
   
#endif
   
#ifndef IClassifierReader__def
#define IClassifierReader__def

class IClassifierReader {

 public:

   // constructor
   IClassifierReader() : fStatusIsClean( true ) {}
   virtual ~IClassifierReader() {}

   // return classifier response
   virtual double GetMvaValue( const std::vector<double>& inputValues ) const = 0;

   // returns classifier status
   bool IsStatusClean() const { return fStatusIsClean; }

 protected:

   bool fStatusIsClean;
};

#endif

class ReadBDT_100_25_01_10 : public IClassifierReader {

 public:

   // constructor
   ReadBDT_100_25_01_10( std::vector<std::string>& theInputVars ) 
      : IClassifierReader(),
        fClassName( "ReadBDT_100_25_01_10" ),
        fNvars( 8 ),
        fIsNormalised( false )
   {      
      // the training input variables
      const char* inputVars[] = { "tmva_deltaphi_bottomlepton", "tmva_deltaphi_bottomtoptag", "tmva_pseudotop_mass", "tmva_ptbalance", "tmva_wass_pt", "tmva_lepton_pt", "tmva_lepton_eta", "tmva_deltaphi_leptonnextjet" };

      // sanity checks
      if (theInputVars.size() <= 0) {
         std::cout << "Problem in class \"" << fClassName << "\": empty input vector" << std::endl;
         fStatusIsClean = false;
      }

      if (theInputVars.size() != fNvars) {
         std::cout << "Problem in class \"" << fClassName << "\": mismatch in number of input values: "
                   << theInputVars.size() << " != " << fNvars << std::endl;
         fStatusIsClean = false;
      }

      // validate input variables
      for (size_t ivar = 0; ivar < theInputVars.size(); ivar++) {
         if (theInputVars[ivar] != inputVars[ivar]) {
            std::cout << "Problem in class \"" << fClassName << "\": mismatch in input variable names" << std::endl
                      << " for variable [" << ivar << "]: " << theInputVars[ivar].c_str() << " != " << inputVars[ivar] << std::endl;
            fStatusIsClean = false;
         }
      }

      // initialize min and max vectors (for normalisation)
      fVmin[0] = 0;
      fVmax[0] = 0;
      fVmin[1] = 0;
      fVmax[1] = 0;
      fVmin[2] = 0;
      fVmax[2] = 0;
      fVmin[3] = 0;
      fVmax[3] = 0;
      fVmin[4] = 0;
      fVmax[4] = 0;
      fVmin[5] = 0;
      fVmax[5] = 0;
      fVmin[6] = 0;
      fVmax[6] = 0;
      fVmin[7] = 0;
      fVmax[7] = 0;

      // initialize input variable types
      fType[0] = 'F';
      fType[1] = 'F';
      fType[2] = 'F';
      fType[3] = 'F';
      fType[4] = 'F';
      fType[5] = 'F';
      fType[6] = 'F';
      fType[7] = 'F';

      // initialize constants
      Initialize();

   }

   // destructor
   virtual ~ReadBDT_100_25_01_10() {
      Clear(); // method-specific
   }

   // the classifier response
   // "inputValues" is a vector of input values in the same order as the 
   // variables given to the constructor
   double GetMvaValue( const std::vector<double>& inputValues ) const;

 private:

   // method-specific destructor
   void Clear();

   // common member variables
   const char* fClassName;

   const size_t fNvars;
   size_t GetNvar()           const { return fNvars; }
   char   GetType( int ivar ) const { return fType[ivar]; }

   // normalisation of input variables
   const bool fIsNormalised;
   bool IsNormalised() const { return fIsNormalised; }
   double fVmin[8];
   double fVmax[8];
   double NormVariable( double x, double xmin, double xmax ) const {
      // normalise to output range: [-1, 1]
      return 2*(x - xmin)/(xmax - xmin) - 1.0;
   }

   // type of input variable: 'F' or 'I'
   char   fType[8];

   // initialize internal variables
   void Initialize();
   double GetMvaValue__( const std::vector<double>& inputValues ) const;

   // private members (method specific)
   std::vector<BDT_100_25_01_10Node*> fForest;       // i.e. root nodes of decision trees
   std::vector<double>                fBoostWeights; // the weights applied in the individual boosts
};

double ReadBDT_100_25_01_10::GetMvaValue__( const std::vector<double>& inputValues ) const
{
   double myMVA = 0;
   double norm  = 0;
   for (unsigned int itree=0; itree<fForest.size(); itree++){
      BDT_100_25_01_10Node *current = fForest[itree];
      while (current->GetNodeType() == 0) { //intermediate node
         if (current->GoesRight(inputValues)) current=(BDT_100_25_01_10Node*)current->GetRight();
         else current=(BDT_100_25_01_10Node*)current->GetLeft();
      }
      myMVA += fBoostWeights[itree] *  current->GetNodeType();
      norm  += fBoostWeights[itree];
   }
   return myMVA /= norm;
};

void ReadBDT_100_25_01_10::Initialize()
{
  // itree = 0
  fBoostWeights.push_back(0.0732521190486979);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 208.986, 0, 1, 0.787079,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.659792,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.486392,-99) , 
3, -0.155687, 0, 0, 0.598717,-99) , 
5, 133.275, 0, 0, 0.684909,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.588365,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.392575,-99) , 
5, 139.062, 0, 0, 0.492248,-99) , 
NN(
0, 
0, 
-1, 354.054, 0, -1, 0.322074,-99) , 
3, -0.088001, 0, 0, 0.351237,-99) , 
7, 1.42797, 0, 0, 0.495082,-99)    );
  // itree = 1
  fBoostWeights.push_back(0.067344);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 154.052, 0, 1, 0.679589,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.604383,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.431338,-99) , 
7, 0.908652, 0, 0, 0.487187,-99) , 
NN(
0, 
0, 
-1, 229.496, 0, -1, 0.330694,-99) , 
2, 398.028, 0, 0, 0.366418,-99) , 
7, 1.42789, 0, 0, 0.502522,-99)    );
  // itree = 2
  fBoostWeights.push_back(0.0653429);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 149.7, 0, 1, 0.682219,-99) , 
NN(
0, 
0, 
-1, -0.259539, 0, -1, 0.361556,-99) , 
7, 1.42797, 0, 0, 0.503218,-99)    );
  // itree = 3
  fBoostWeights.push_back(0.0668321);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 208.984, 0, 1, 0.767729,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.633027,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.482126,-99) , 
7, 1.89516, 0, 0, 0.581189,-99) , 
5, 133.279, 0, 0, 0.665597,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.602824,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.429467,-99) , 
4, 287.727, 0, 0, 0.499097,-99) , 
NN(
0, 
0, 
-1, 199.865, 0, -1, 0.326527,-99) , 
2, 396.578, 0, 0, 0.366929,-99) , 
7, 1.42789, 0, 0, 0.49769,-99)    );
  // itree = 4
  fBoostWeights.push_back(0.0620468);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 149.7, 0, 1, 0.660911,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.546963,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.286138,-99) , 
0, 1.14255, 0, 0, 0.473185,-99) , 
NN(
0, 
0, 
-1, -0.0301352, 0, -1, 0.342021,-99) , 
5, 138.536, 0, 0, 0.374701,-99) , 
7, 1.42797, 0, 0, 0.500007,-99)    );
  // itree = 5
  fBoostWeights.push_back(0.0606953);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 154.052, 0, 1, 0.686239,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.680481,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.454525,-99) , 
4, 273.121, 0, 0, 0.508223,-99) , 
NN(
0, 
0, 
-1, 394.398, 0, -1, 0.35499,-99) , 
7, 1.09021, 0, 0, 0.400067,-99) , 
7, 1.71327, 0, 0, 0.503521,-99)    );
  // itree = 6
  fBoostWeights.push_back(0.0553736);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 154.046, 0, 1, 0.656838,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.657222,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.484401,-99) , 
1, 0.571201, 0, 0, 0.520175,-99) , 
NN(
0, 
0, 
-1, 205.092, 0, -1, 0.361969,-99) , 
2, 410.949, 0, 0, 0.395919,-99) , 
7, 1.42789, 0, 0, 0.509957,-99)    );
  // itree = 7
  fBoostWeights.push_back(0.0567872);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 154.052, 0, 1, 0.652278,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.709431,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.459868,-99) , 
5, 215.491, 0, 0, 0.505278,-99) , 
NN(
0, 
0, 
-1, 221.833, 0, -1, 0.35294,-99) , 
2, 381.778, 0, 0, 0.392878,-99) , 
7, 1.42797, 0, 0, 0.50796,-99)    );
  // itree = 8
  fBoostWeights.push_back(0.0524453);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 139.252, 0, 1, 0.670279,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.608072,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.460393,-99) , 
5, 149.704, 0, 0, 0.517976,-99) , 
NN(
0, 
0, 
-1, 0.778817, 0, -1, 0.378346,-99) , 
3, -0.163798, 0, 0, 0.421569,-99) , 
7, 1.71347, 0, 0, 0.511087,-99)    );
  // itree = 9
  fBoostWeights.push_back(0.0524264);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 208.984, 0, 1, 0.741221,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.606396,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.489227,-99) , 
7, 1.89529, 0, 0, 0.565719,-99) , 
5, 133.275, 0, 0, 0.643285,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.641338,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.46646,-99) , 
2, 396.578, 0, 0, 0.52984,-99) , 
NN(
0, 
0, 
-1, 0.856796, 0, -1, 0.378514,-99) , 
3, -0.0886912, 0, 0, 0.405118,-99) , 
7, 1.42797, 0, 0, 0.510202,-99)    );
  // itree = 10
  fBoostWeights.push_back(0.047913);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 154.044, 0, 1, 0.634229,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.632462,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.479171,-99) , 
3, -0.0878809, 0, 0, 0.520365,-99) , 
NN(
0, 
0, 
-1, 229.014, 0, -1, 0.379206,-99) , 
2, 397.574, 0, 0, 0.412088,-99) , 
7, 1.42772, 0, 0, 0.509562,-99)    );
  // itree = 11
  fBoostWeights.push_back(0.0465087);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 135.023, 0, 1, 0.651103,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.659839,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.491945,-99) , 
2, 395.095, 0, 0, 0.555664,-99) , 
NN(
0, 
0, 
-1, 1.09019, 0, -1, 0.399415,-99) , 
3, -0.088001, 0, 0, 0.431023,-99) , 
7, 1.71327, 0, 0, 0.510137,-99)    );
  // itree = 12
  fBoostWeights.push_back(0.0434601);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.0650433, 0, 1, 0.730903,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.601117,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.482904,-99) , 
7, 1.86906, 0, 0, 0.548873,-99) , 
5, 154.044, 0, 0, 0.604001,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.504157,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.361493,-99) , 
0, 1.14246, 0, 0, 0.457661,-99) , 
NN(
0, 
0, 
-1, 309.448, 0, -1, 0.365758,-99) , 
3, -0.25979, 0, 0, 0.403844,-99) , 
7, 1.14238, 0, 0, 0.509718,-99)    );
  // itree = 13
  fBoostWeights.push_back(0.0471037);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.810573,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.639784,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.486936,-99) , 
7, 1.14227, 0, 0, 0.609086,-99) , 
5, 228.493, 0, 0, 0.641412,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.585696,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.445881,-99) , 
5, 101.069, 0, 0, 0.51074,-99) , 
NN(
0, 
0, 
-1, 366.426, 0, -1, 0.385042,-99) , 
7, 1.14214, 0, 0, 0.431235,-99) , 
3, -0.0886912, 0, 0, 0.508769,-99)    );
  // itree = 14
  fBoostWeights.push_back(0.045527);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 135.019, 0, 1, 0.692363,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.591541,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.430938,-99) , 
0, 1.42811, 0, 0, 0.553061,-99) , 
7, 1.71349, 0, 0, 0.643615,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.653403,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.486168,-99) , 
5, 147.337, 0, 0, 0.516509,-99) , 
NN(
0, 
0, 
-1, 0.856862, 0, -1, 0.385969,-99) , 
7, 1.14195, 0, 0, 0.43392,-99) , 
3, -0.0876303, 0, 0, 0.511376,-99)    );
  // itree = 15
  fBoostWeights.push_back(0.0422291);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 216.55, 0, 1, 0.63783,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.659387,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.470624,-99) , 
7, 0.934618, 0, 0, 0.548371,-99) , 
NN(
0, 
0, 
-1, 307.146, 0, -1, 0.414802,-99) , 
4, 280.912, 0, 0, 0.441378,-99) , 
7, 1.71356, 0, 0, 0.512749,-99)    );
  // itree = 16
  fBoostWeights.push_back(0.040427);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 154.048, 0, 1, 0.626792,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.598005,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.390819,-99) , 
0, 1.1424, 0, 0, 0.547465,-99) , 
NN(
0, 
0, 
-1, 356.379, 0, -1, 0.421112,-99) , 
5, 138.536, 0, 0, 0.453865,-99) , 
7, 1.71336, 0, 0, 0.515938,-99)    );
  // itree = 17
  fBoostWeights.push_back(0.039755);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, -0.656, 0, 1, 0.727938,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.586875,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.479692,-99) , 
3, -0.12559, 0, 0, 0.54488,-99) , 
5, 154.051, 0, 0, 0.604143,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.578758,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.447503,-99) , 
7, 0.649056, 0, 0, 0.517223,-99) , 
NN(
0, 
0, 
-1, 234.5, 0, -1, 0.410104,-99) , 
2, 410.949, 0, 0, 0.432557,-99) , 
7, 1.42797, 0, 0, 0.507778,-99)    );
  // itree = 18
  fBoostWeights.push_back(0.0386087);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 220.031, 0, 1, 0.629214,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.574309,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.448189,-99) , 
2, 293.105, 0, 0, 0.516007,-99) , 
NN(
0, 
0, 
-1, 362.334, 0, -1, 0.417274,-99) , 
7, 1.14214, 0, 0, 0.453633,-99) , 
3, -0.0886912, 0, 0, 0.517872,-99)    );
  // itree = 19
  fBoostWeights.push_back(0.0356259);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 154.044, 0, 1, 0.59479,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.593238,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.504831,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.403224,-99) , 
3, -0.12481, 0, 0, 0.421826,-99) , 
5, 228.121, 0, 0, 0.431734,-99) , 
7, 1.14238, 0, 0, 0.517708,-99)    );
  // itree = 20
  fBoostWeights.push_back(0.0384657);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 240.35, 0, 1, 0.706682,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.563672,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.472771,-99) , 
4, 204.627, 0, 0, 0.527907,-99) , 
5, 149.7, 0, 0, 0.586203,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.598301,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.479592,-99) , 
7, 0.622972, 0, 0, 0.536973,-99) , 
NN(
0, 
0, 
-1, 211.316, 0, -1, 0.403594,-99) , 
2, 426.197, 0, 0, 0.430533,-99) , 
7, 1.14231, 0, 0, 0.512837,-99)    );
  // itree = 21
  fBoostWeights.push_back(0.0369499);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 1.14247, 0, 1, 0.663081,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.561458,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.410869,-99) , 
1, 1.71329, 1, 0, 0.542196,-99) , 
5, 149.699, 0, 0, 0.590827,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.55865,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.446382,-99) , 
2, 319.839, 0, 0, 0.489259,-99) , 
NN(
0, 
0, 
-1, 354.054, 0, -1, 0.39988,-99) , 
7, 0.855962, 0, 0, 0.441966,-99) , 
3, -0.162484, 0, 0, 0.513726,-99)    );
  // itree = 22
  fBoostWeights.push_back(0.0333652);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 1.14247, 0, 1, 0.676773,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.574851,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.497787,-99) , 
7, 1.42765, 0, 0, 0.548984,-99) , 
5, 154.043, 0, 0, 0.5988,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.639262,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.48757,-99) , 
1, 0.571222, 0, 0, 0.522149,-99) , 
NN(
0, 
0, 
-1, 0.85661, 0, -1, 0.424701,-99) , 
2, 368.255, 0, 0, 0.449934,-99) , 
3, -0.164043, 0, 0, 0.522312,-99)    );
  // itree = 23
  fBoostWeights.push_back(0.0356359);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.773485,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.590853,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.447441,-99) , 
0, 1.71363, 0, 0, 0.569948,-99) , 
5, 249.398, 0, 0, 0.589351,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.564943,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.446492,-99) , 
5, 94.873, 0, 0, 0.500458,-99) , 
NN(
0, 
0, 
-1, 0.856805, 0, -1, 0.413078,-99) , 
7, 0.856611, 0, 0, 0.4537,-99) , 
3, -0.163233, 0, 0, 0.519897,-99)    );
  // itree = 24
  fBoostWeights.push_back(0.0288828);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 240.336, 0, 1, 0.687647,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.580849,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.499314,-99) , 
3, -0.0211315, 0, 0, 0.523684,-99) , 
5, 149.702, 0, 0, 0.576649,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.570809,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.480411,-99) , 
0, 2.57037, 1, 0, 0.509013,-99) , 
NN(
0, 
0, 
-1, 236.019, 0, -1, 0.426715,-99) , 
2, 412.399, 0, 0, 0.443801,-99) , 
7, 1.14231, 0, 0, 0.513691,-99)    );
  // itree = 25
  fBoostWeights.push_back(0.0317609);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.776614,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.592555,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.440762,-99) , 
1, 1.71359, 1, 0, 0.576669,-99) , 
5, 228.126, 0, 0, 0.606657,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.566511,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.413793,-99) , 
0, 1.1424, 0, 0, 0.53325,-99) , 
NN(
0, 
0, 
-1, 0.855888, 0, -1, 0.448783,-99) , 
5, 125.626, 0, 0, 0.472952,-99) , 
3, -0.0886912, 0, 0, 0.521496,-99)    );
  // itree = 26
  fBoostWeights.push_back(0.0281224);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 220.031, 0, 1, 0.602257,-99) , 
NN(
NN(
0, 
0, 
-1, 0.571185, 0, 1, 0.553256,-99) , 
NN(
0, 
0, 
-1, 204.688, 0, -1, 0.448918,-99) , 
2, 410.569, 0, 0, 0.471457,-99) , 
7, 1.71334, 0, 0, 0.51865,-99)    );
  // itree = 27
  fBoostWeights.push_back(0.0296448);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.76258,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.582273,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.489355,-99) , 
2, 311.374, 0, 0, 0.541036,-99) , 
5, 199.758, 0, 0, 0.573776,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.508988,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.415752,-99) , 
0, 1.14252, 0, 0, 0.477548,-99) , 
NN(
0, 
0, 
-1, 0.934571, 0, -1, 0.403201,-99) , 
3, -0.31766, 0, 0, 0.441974,-99) , 
7, 1.14232, 0, 0, 0.511922,-99)    );
  // itree = 28
  fBoostWeights.push_back(0.0287623);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.0650433, 0, 1, 0.685188,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.578339,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.428345,-99) , 
0, 1.14245, 0, 0, 0.531263,-99) , 
7, 1.14242, 0, 0, 0.628103,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.569355,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.487077,-99) , 
5, 97.2912, 0, 0, 0.526206,-99) , 
NN(
0, 
0, 
-1, 300.633, 0, -1, 0.44608,-99) , 
7, 1.14223, 0, 0, 0.485618,-99) , 
5, 154.043, 0, 0, 0.521266,-99)    );
  // itree = 29
  fBoostWeights.push_back(0.032118);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 220.39, 0, 1, 0.671023,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.546307,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.448888,-99) , 
2, 271.794, 0, 0, 0.511661,-99) , 
5, 139.248, 0, 0, 0.571083,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.542079,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.460415,-99) , 
0, 2.85611, 1, 0, 0.510647,-99) , 
NN(
0, 
0, 
-1, 205.092, 0, -1, 0.430158,-99) , 
2, 410.949, 0, 0, 0.44744,-99) , 
7, 1.14224, 0, 0, 0.512672,-99)    );
  // itree = 30
  fBoostWeights.push_back(0.0275023);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 1.14216, 0, 1, 0.719506,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.590683,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.48503,-99) , 
5, 98.5749, 0, 0, 0.546965,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.511516,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.430571,-99) , 
2, 356.379, 0, 0, 0.453924,-99) , 
7, 1.14223, 0, 0, 0.502113,-99) , 
5, 228.122, 0, 0, 0.518309,-99)    );
  // itree = 31
  fBoostWeights.push_back(0.0296951);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 240.339, 0, 1, 0.676264,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.541412,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.446326,-99) , 
6, -1.09081, 0, 0, 0.526471,-99) , 
5, 149.7, 0, 0, 0.574036,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.519663,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.435611,-99) , 
1, 1.99916, 1, 0, 0.49336,-99) , 
NN(
0, 
0, 
-1, 317.824, 0, -1, 0.420021,-99) , 
3, -0.25979, 0, 0, 0.451032,-99) , 
7, 1.14224, 0, 0, 0.516086,-99)    );
  // itree = 32
  fBoostWeights.push_back(0.022608);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 1.14201, 0, 1, 0.710958,-99) , 
NN(
NN(
0, 
0, 
-1, 163.347, 0, 1, 0.541634,-99) , 
NN(
0, 
0, 
-1, 0.856802, 0, -1, 0.454597,-99) , 
7, 1.14238, 0, 0, 0.499214,-99) , 
5, 228.121, 0, 0, 0.515409,-99)    );
  // itree = 33
  fBoostWeights.push_back(0.0269724);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.769061,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.585418,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.451878,-99) , 
1, 1.71329, 1, 0, 0.572053,-99) , 
5, 258.09, 0, 0, 0.58962,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.5576,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.475736,-99) , 
2, 318.728, 0, 0, 0.510576,-99) , 
NN(
0, 
0, 
-1, 354.054, 0, -1, 0.43974,-99) , 
7, 0.856607, 0, 0, 0.476298,-99) , 
3, -0.0886912, 0, 0, 0.517645,-99)    );
  // itree = 34
  fBoostWeights.push_back(0.0250386);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.00946798, 0, 1, 0.677085,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.549798,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.39005,-99) , 
1, 1.99919, 1, 0, 0.502551,-99) , 
7, 1.14231, 0, 0, 0.613155,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.562828,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.492586,-99) , 
5, 106.75, 0, 0, 0.5204,-99) , 
NN(
0, 
0, 
-1, 114.294, 0, -1, 0.453744,-99) , 
7, 1.14223, 0, 0, 0.486417,-99) , 
5, 154.043, 0, 0, 0.517523,-99)    );
  // itree = 35
  fBoostWeights.push_back(0.0250607);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 258.086, 0, 1, 0.575857,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.594267,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.468629,-99) , 
5, 156.709, 0, 0, 0.483942,-99) , 
NN(
0, 
0, 
-1, 0.551738, 0, -1, 0.409556,-99) , 
0, 0.856804, 0, 0, 0.468812,-99) , 
3, -0.163798, 0, 0, 0.520916,-99)    );
  // itree = 36
  fBoostWeights.push_back(0.0213021);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 1.1422, 0, 1, 0.707666,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.577739,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.492688,-99) , 
7, 1.14224, 0, 0, 0.542656,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.531834,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.465161,-99) , 
4, 278.171, 0, 0, 0.473901,-99) , 
5, 114.676, 0, 0, 0.501764,-99) , 
5, 227.862, 0, 0, 0.51755,-99)    );
  // itree = 37
  fBoostWeights.push_back(0.021037);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.750818,-99) , 
NN(
NN(
0, 
0, 
-1, 163.501, 0, 1, 0.540583,-99) , 
NN(
0, 
0, 
-1, -0.241018, 0, -1, 0.453816,-99) , 
7, 0.856672, 0, 0, 0.509259,-99) , 
5, 258.085, 0, 0, 0.520622,-99)    );
  // itree = 38
  fBoostWeights.push_back(0.0192636);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.729146,-99) , 
NN(
NN(
0, 
0, 
-1, 158.763, 0, 1, 0.545083,-99) , 
NN(
0, 
0, 
-1, 0.571205, 0, -1, 0.46802,-99) , 
7, 1.42772, 0, 0, 0.501,-99) , 
5, 249.397, 0, 0, 0.513414,-99)    );
  // itree = 39
  fBoostWeights.push_back(0.0214041);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.00448917, 0, 1, 0.667534,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.525233,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.420078,-99) , 
0, 1.14244, 0, 0, 0.489268,-99) , 
7, 1.1424, 0, 0, 0.603397,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.566988,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.489566,-99) , 
2, 308.584, 0, 0, 0.538533,-99) , 
NN(
0, 
0, 
-1, -0.46504, 0, -1, 0.472907,-99) , 
3, -0.0236534, 0, 0, 0.485074,-99) , 
5, 154.043, 0, 0, 0.514096,-99)    );
  // itree = 40
  fBoostWeights.push_back(0.022844);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 397.207, 0, 1, 0.72124,-99) , 
NN(
NN(
0, 
0, 
-1, 158.724, 0, 1, 0.563151,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.533459,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.459208,-99) , 
2, 367.122, 0, 0, 0.479988,-99) , 
7, 1.71356, 0, 0, 0.509131,-99) , 
5, 249.397, 0, 0, 0.520799,-99)    );
  // itree = 41
  fBoostWeights.push_back(0.0170835);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 1.14234, 0, 1, 0.694587,-99) , 
NN(
NN(
0, 
0, 
-1, 130.836, 0, 1, 0.530687,-99) , 
NN(
0, 
0, 
-1, 1.42799, 0, -1, 0.47058,-99) , 
7, 1.14238, 0, 0, 0.501501,-99) , 
5, 227.862, 0, 0, 0.516211,-99)    );
  // itree = 42
  fBoostWeights.push_back(0.0178218);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.734214,-99) , 
NN(
NN(
0, 
0, 
-1, 163.5, 0, 1, 0.540563,-99) , 
NN(
0, 
0, 
-1, 0.856796, 0, -1, 0.471616,-99) , 
7, 1.14224, 0, 0, 0.507304,-99) , 
5, 258.086, 0, 0, 0.518391,-99)    );
  // itree = 43
  fBoostWeights.push_back(0.0176441);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.725887,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.561184,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.452705,-99) , 
0, 1.14242, 0, 0, 0.546004,-99) , 
NN(
0, 
0, 
-1, 0.856803, 0, -1, 0.478681,-99) , 
5, 125.667, 0, 0, 0.502646,-99) , 
5, 258.085, 0, 0, 0.51337,-99)    );
  // itree = 44
  fBoostWeights.push_back(0.017494);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.721416,-99) , 
NN(
NN(
0, 
0, 
-1, 1.14242, 0, 1, 0.555239,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.530771,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.477639,-99) , 
3, -0.0245711, 0, 0, 0.486225,-99) , 
5, 125.667, 0, 0, 0.510769,-99) , 
5, 258.085, 0, 0, 0.52059,-99)    );
  // itree = 45
  fBoostWeights.push_back(0.0157311);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.716301,-99) , 
NN(
NN(
0, 
0, 
-1, 158.761, 0, 1, 0.540989,-99) , 
NN(
0, 
0, 
-1, 1.14239, 0, -1, 0.479853,-99) , 
7, 1.4278, 0, 0, 0.506014,-99) , 
5, 249.398, 0, 0, 0.517449,-99)    );
  // itree = 46
  fBoostWeights.push_back(0.017754);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.726877,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.587407,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.485985,-99) , 
7, 1.14226, 0, 0, 0.54725,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.522847,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.477933,-99) , 
7, 1.9989, 0, 0, 0.487308,-99) , 
5, 125.667, 0, 0, 0.508563,-99) , 
5, 258.086, 0, 0, 0.519069,-99)    );
  // itree = 47
  fBoostWeights.push_back(0.0171563);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 1.14234, 0, 1, 0.687344,-99) , 
NN(
NN(
0, 
0, 
-1, 296.836, 0, 1, 0.580096,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.515482,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.476678,-99) , 
5, 114.676, 0, 0, 0.49084,-99) , 
3, 0.00976172, 0, 0, 0.506494,-99) , 
5, 227.862, 0, 0, 0.520213,-99)    );
  // itree = 48
  fBoostWeights.push_back(0.0211142);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.698721,-99) , 
NN(
NN(
0, 
0, 
-1, 1.14236, 0, 1, 0.544943,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.524542,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.416254,-99) , 
2, 194.917, 0, 0, 0.487938,-99) , 
2, 321.168, 0, 0, 0.513675,-99) , 
5, 249.397, 0, 0, 0.52312,-99)    );
  // itree = 49
  fBoostWeights.push_back(0.0137227);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.696351,-99) , 
NN(
NN(
0, 
0, 
-1, 0.570648, 1, 1, 0.606214,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.538519,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.489303,-99) , 
7, 1.71336, 0, 0, 0.505157,-99) , 
3, 0.10686, 0, 0, 0.51351,-99) , 
5, 258.086, 0, 0, 0.521533,-99)    );
  // itree = 50
  fBoostWeights.push_back(0.0159706);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 1.14234, 0, 1, 0.687383,-99) , 
NN(
NN(
0, 
0, 
-1, 163.323, 0, 1, 0.5572,-99) , 
NN(
0, 
0, 
-1, 1.52729, 1, -1, 0.48117,-99) , 
3, -0.0242669, 0, 0, 0.498465,-99) , 
5, 228.121, 0, 0, 0.512985,-99)    );
  // itree = 51
  fBoostWeights.push_back(0.0145255);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 1.14241, 0, 1, 0.691051,-99) , 
NN(
NN(
0, 
0, 
-1, 163.583, 0, 1, 0.558167,-99) , 
NN(
0, 
0, 
-1, 0.856799, 0, -1, 0.486492,-99) , 
3, -0.0242669, 0, 0, 0.503176,-99) , 
5, 228.493, 0, 0, 0.517054,-99)    );
  // itree = 52
  fBoostWeights.push_back(0.012494);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.698153,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.559549,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.478156,-99) , 
0, 1.42799, 0, 0, 0.545757,-99) , 
NN(
0, 
0, 
-1, 114.294, 0, -1, 0.493309,-99) , 
5, 125.668, 0, 0, 0.512115,-99) , 
5, 258.085, 0, 0, 0.52046,-99)    );
  // itree = 53
  fBoostWeights.push_back(0.0136242);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 1.14234, 0, 1, 0.678648,-99) , 
NN(
NN(
0, 
0, 
-1, 163.328, 0, 1, 0.54419,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.569257,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.488573,-99) , 
3, 0.107079, 0, 0, 0.492986,-99) , 
7, 1.99881, 0, 0, 0.506453,-99) , 
5, 228.121, 0, 0, 0.519271,-99)    );
  // itree = 54
  fBoostWeights.push_back(0.0113133);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.692438,-99) , 
NN(
NN(
0, 
0, 
-1, 1.42748, 0, 1, 0.576831,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.566157,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.494011,-99) , 
4, 322.818, 0, 0, 0.5001,-99) , 
5, 176.892, 0, 0, 0.509579,-99) , 
5, 249.401, 0, 0, 0.519143,-99)    );
  // itree = 55
  fBoostWeights.push_back(0.00933279);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.713842,-99) , 
NN(
NN(
0, 
0, 
-1, 1.42748, 0, 1, 0.588331,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.615753,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.49939,-99) , 
4, 388.524, 0, 0, 0.502973,-99) , 
5, 182.418, 0, 0, 0.512771,-99) , 
5, 258.085, 0, 0, 0.522318,-99)    );
  // itree = 56
  fBoostWeights.push_back(0.0145253);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.689154,-99) , 
NN(
NN(
0, 
0, 
-1, 176.886, 0, 1, 0.529223,-99) , 
NN(
0, 
0, 
-1, -0.438388, 0, -1, 0.47501,-99) , 
7, 0.856785, 0, 0, 0.509508,-99) , 
5, 249.397, 0, 0, 0.519038,-99)    );
  // itree = 57
  fBoostWeights.push_back(0.0170245);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 1.42792, 0, 1, 0.64971,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.533587,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.464985,-99) , 
6, -1.0909, 0, 0, 0.523239,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.517442,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.459058,-99) , 
1, 2.05859, 1, 0, 0.468371,-99) , 
0, 1.42799, 0, 0, 0.510674,-99) , 
5, 228.492, 0, 0, 0.520189,-99)    );
  // itree = 58
  fBoostWeights.push_back(0.0144838);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.696934,-99) , 
NN(
NN(
0, 
0, 
-1, 1.42703, 0, 1, 0.601231,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.517114,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.456905,-99) , 
6, 1.09091, 1, 0, 0.50774,-99) , 
5, 195.001, 0, 0, 0.514897,-99) , 
5, 249.397, 0, 0, 0.524401,-99)    );
  // itree = 59
  fBoostWeights.push_back(0.0142102);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.698736,-99) , 
NN(
NN(
0, 
0, 
-1, 163.5, 0, 1, 0.528527,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.505637,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.46062,-99) , 
3, -0.259381, 0, 0, 0.477855,-99) , 
7, 0.856672, 0, 0, 0.510202,-99) , 
5, 258.085, 0, 0, 0.518678,-99)    );
  // itree = 60
  fBoostWeights.push_back(0.0185637);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 1.1422, 0, 1, 0.65471,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.537813,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.478617,-99) , 
6, 1.09095, 1, 0, 0.528952,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.512942,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.443632,-99) , 
2, 321.02, 0, 0, 0.466332,-99) , 
3, -0.2606, 0, 0, 0.50453,-99) , 
5, 228.121, 0, 0, 0.515178,-99)    );
  // itree = 61
  fBoostWeights.push_back(0.0127524);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 1.1422, 0, 1, 0.653666,-99) , 
NN(
NN(
0, 
0, 
-1, 163.583, 0, 1, 0.523758,-99) , 
NN(
0, 
0, 
-1, 0.856788, 0, -1, 0.479331,-99) , 
7, 0.856573, 0, 0, 0.507624,-99) , 
5, 228.492, 0, 0, 0.51788,-99)    );
  // itree = 62
  fBoostWeights.push_back(0.0170647);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.654638, 1, 1, 0.625528,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.54767,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.435396,-99) , 
0, 1.14242, 0, 0, 0.512043,-99) , 
7, 1.14243, 0, 0, 0.582699,-99) , 
NN(
NN(
0, 
0, 
-1, -0.65028, 0, 1, 0.535818,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.523019,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.478679,-99) , 
2, 381.778, 0, 0, 0.489478,-99) , 
5, 125.668, 0, 0, 0.498193,-99) , 
5, 154.043, 0, 0, 0.519008,-99)    );
  // itree = 63
  fBoostWeights.push_back(0.0132517);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.691312,-99) , 
NN(
NN(
0, 
0, 
-1, 182.418, 0, 1, 0.529537,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.515273,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.474815,-99) , 
2, 322.673, 0, 0, 0.489104,-99) , 
3, -0.161038, 0, 0, 0.508025,-99) , 
5, 258.086, 0, 0, 0.516553,-99)    );
  // itree = 64
  fBoostWeights.push_back(0.0131922);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.685831,-99) , 
NN(
NN(
0, 
0, 
-1, 1.14174, 0, 1, 0.596422,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.525516,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.485319,-99) , 
3, -0.217356, 0, 0, 0.506838,-99) , 
5, 201.333, 0, 0, 0.513259,-99) , 
5, 258.086, 0, 0, 0.520823,-99)    );
  // itree = 65
  fBoostWeights.push_back(0.0101245);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.673487,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.574548,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.440202,-99) , 
0, 1.71367, 0, 0, 0.552902,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.502304,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.427738,-99) , 
6, -1.52703, 0, 0, 0.496942,-99) , 
5, 163.501, 0, 0, 0.506642,-99) , 
5, 258.085, 0, 0, 0.513875,-99)    );
  // itree = 66
  fBoostWeights.push_back(0.0129546);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.689599,-99) , 
NN(
NN(
0, 
0, 
-1, 0.0941754, 0, 1, 0.5247,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.524452,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.474997,-99) , 
4, 270.936, 0, 0, 0.481576,-99) , 
5, 87.8347, 0, 0, 0.508504,-99) , 
5, 258.085, 0, 0, 0.516806,-99)    );
  // itree = 67
  fBoostWeights.push_back(0.0103108);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.670318,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.609276,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.474733,-99) , 
7, 0.856636, 0, 0, 0.571304,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.504058,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.438249,-99) , 
6, 1.52729, 1, 0, 0.499009,-99) , 
5, 176.876, 0, 0, 0.507809,-99) , 
5, 249.397, 0, 0, 0.516218,-99)    );
  // itree = 68
  fBoostWeights.push_back(0.01266);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.690003,-99) , 
NN(
NN(
0, 
0, 
-1, 201.335, 0, 1, 0.518518,-99) , 
NN(
0, 
0, 
-1, 0.856796, 0, -1, 0.466912,-99) , 
7, 0.856785, 0, 0, 0.500082,-99) , 
5, 258.085, 0, 0, 0.509087,-99)    );
  // itree = 69
  fBoostWeights.push_back(0.00875288);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.672396,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.610146,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.489268,-99) , 
7, 1.14197, 0, 0, 0.565183,-99) , 
NN(
0, 
0, 
-1, 1.5274, 1, -1, 0.49437,-99) , 
5, 176.88, 0, 0, 0.502936,-99) , 
5, 249.397, 0, 0, 0.511557,-99)    );
  // itree = 70
  fBoostWeights.push_back(0.00860698);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 1.14227, 0, 1, 0.639995,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.56698,-99) , 
NN(
0, 
0, 
-1, -1.09099, 0, -1, 0.492103,-99) , 
3, 0.10686, 0, 0, 0.497968,-99) , 
5, 227.862, 0, 0, 0.507973,-99)    );
  // itree = 71
  fBoostWeights.push_back(0.00863507);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.687955,-99) , 
NN(
NN(
0, 
0, 
-1, 319.098, 1, 1, 0.582166,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.50383,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.432002,-99) , 
6, 1.52729, 1, 0, 0.498553,-99) , 
5, 201.335, 0, 0, 0.504296,-99) , 
5, 258.086, 0, 0, 0.512694,-99)    );
  // itree = 72
  fBoostWeights.push_back(0.0111171);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.667103,-99) , 
NN(
NN(
0, 
0, 
-1, 1.42788, 0, 1, 0.57722,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.514069,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.474931,-99) , 
5, 77.5096, 0, 0, 0.502354,-99) , 
5, 201.303, 0, 0, 0.507477,-99) , 
5, 258.085, 0, 0, 0.51439,-99)    );
  // itree = 73
  fBoostWeights.push_back(0.00983778);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 1.1422, 0, 1, 0.646495,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.553497,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.493549,-99) , 
2, 304.54, 0, 0, 0.53335,-99) , 
NN(
0, 
0, 
-1, -1.52701, 0, -1, 0.491551,-99) , 
3, -0.0225297, 0, 0, 0.501016,-99) , 
5, 228.121, 0, 0, 0.511538,-99)    );
  // itree = 74
  fBoostWeights.push_back(0.0102956);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.690077,-99) , 
NN(
NN(
0, 
0, 
-1, 317.51, 0, 1, 0.555843,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.506714,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.475657,-99) , 
5, 87.8342, 0, 0, 0.494586,-99) , 
3, 0.0911499, 0, 0, 0.500265,-99) , 
5, 258.085, 0, 0, 0.509287,-99)    );
  // itree = 75
  fBoostWeights.push_back(0.00850063);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.681283,-99) , 
NN(
NN(
0, 
0, 
-1, 1.14238, 0, 1, 0.56169,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.500746,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.45196,-99) , 
5, 62.0391, 0, 0, 0.4938,-99) , 
5, 182.417, 0, 0, 0.501422,-99) , 
5, 258.085, 0, 0, 0.50965,-99)    );
  // itree = 76
  fBoostWeights.push_back(0.00826815);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.698926,-99) , 
NN(
NN(
0, 
0, 
-1, 1.42703, 0, 1, 0.588999,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.500349,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.429233,-99) , 
6, 1.52721, 1, 0, 0.495015,-99) , 
5, 201.333, 0, 0, 0.50178,-99) , 
5, 258.085, 0, 0, 0.511281,-99)    );
  // itree = 77
  fBoostWeights.push_back(0.0107457);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.726164,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.488531,-99) , 
7, 1.1422, 0, 0, 0.641766,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.508216,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.436381,-99) , 
6, -1.52703, 0, 0, 0.503144,-99) , 
NN(
0, 
0, 
-1, 1.42803, 0, -1, 0.417646,-99) , 
4, 118.919, 0, 0, 0.496713,-99) , 
5, 228.492, 0, 0, 0.507034,-99)    );
  // itree = 78
  fBoostWeights.push_back(0.00999949);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 1.14234, 0, 1, 0.631961,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.577446,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.481699,-99) , 
7, 1.14197, 0, 0, 0.542016,-99) , 
NN(
0, 
0, 
-1, 2.85597, 1, -1, 0.490068,-99) , 
5, 163.35, 0, 0, 0.497919,-99) , 
5, 228.121, 0, 0, 0.507408,-99)    );
  // itree = 79
  fBoostWeights.push_back(0.00968632);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 1.14215, 0, 1, 0.638255,-99) , 
NN(
NN(
0, 
0, 
-1, 179.328, 0, 1, 0.534793,-99) , 
NN(
0, 
0, 
-1, 1.52669, 1, -1, 0.49004,-99) , 
3, -0.0231637, 0, 0, 0.500191,-99) , 
5, 227.862, 0, 0, 0.509875,-99)    );
  // itree = 80
  fBoostWeights.push_back(0.0130836);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.686848,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.533964,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.417916,-99) , 
6, 1.52678, 1, 0, 0.526387,-99) , 
NN(
0, 
0, 
-1, -1.5272, 0, -1, 0.486135,-99) , 
5, 106.751, 0, 0, 0.505518,-99) , 
5, 258.085, 0, 0, 0.514043,-99)    );
  // itree = 81
  fBoostWeights.push_back(0.00780964);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 1.14173, 0, 1, 0.642131,-99) , 
NN(
NN(
0, 
0, 
-1, 195.519, 0, 1, 0.505971,-99) , 
NN(
0, 
0, 
-1, 0.571247, 0, -1, 0.440776,-99) , 
6, 1.52727, 1, 0, 0.501283,-99) , 
5, 227.862, 0, 0, 0.511622,-99)    );
  // itree = 82
  fBoostWeights.push_back(0.00931503);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.693359,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.49496,-99) , 
7, 1.14241, 0, 0, 0.61951,-99) , 
NN(
NN(
0, 
0, 
-1, 210.453, 0, 1, 0.571791,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.514721,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.489057,-99) , 
2, 320.763, 0, 0, 0.500149,-99) , 
5, 195.732, 0, 0, 0.50414,-99) , 
5, 228.121, 0, 0, 0.512086,-99)    );
  // itree = 83
  fBoostWeights.push_back(0.00983663);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 1.14241, 0, 1, 0.639259,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.55379,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.498363,-99) , 
5, 163.346, 0, 0, 0.507636,-99) , 
NN(
0, 
0, 
-1, 114.292, 0, -1, 0.474822,-99) , 
7, 0.8568, 0, 0, 0.495782,-99) , 
5, 228.122, 0, 0, 0.506069,-99)    );
  // itree = 84
  fBoostWeights.push_back(0.010316);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 1.14241, 0, 1, 0.646822,-99) , 
NN(
NN(
0, 
0, 
-1, 179.814, 0, 1, 0.538056,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.503759,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.457419,-99) , 
6, -1.09039, 0, 0, 0.496704,-99) , 
3, -0.0238508, 0, 0, 0.506186,-99) , 
5, 228.492, 0, 0, 0.516507,-99)    );
  // itree = 85
  fBoostWeights.push_back(0.0139222);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 1.14165, 0, 1, 0.655518,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.519962,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.452431,-99) , 
6, -1.44783, 0, 0, 0.513559,-99) , 
NN(
0, 
0, 
-1, 1.567, 1, -1, 0.461255,-99) , 
6, 1.09094, 1, 0, 0.505439,-99) , 
5, 228.121, 0, 0, 0.516554,-99)    );
  // itree = 86
  fBoostWeights.push_back(0.00824852);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.640312,-99) , 
NN(
NN(
0, 
0, 
-1, 176.877, 0, 1, 0.51462,-99) , 
NN(
0, 
0, 
-1, 176.881, 1, -1, 0.485999,-99) , 
7, 0.856672, 0, 0, 0.504154,-99) , 
5, 249.398, 0, 0, 0.510875,-99)    );
  // itree = 87
  fBoostWeights.push_back(0.0106057);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.666923,-99) , 
NN(
NN(
0, 
0, 
-1, -0.653992, 0, 1, 0.548175,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.507094,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.465304,-99) , 
6, 1.091, 1, 0, 0.500448,-99) , 
3, -0.0231836, 0, 0, 0.511514,-99) , 
5, 258.085, 0, 0, 0.518387,-99)    );
  // itree = 88
  fBoostWeights.push_back(0.00904921);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.65168,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.576255,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.50689,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.480047,-99) , 
3, -0.21797, 0, 0, 0.49448,-99) , 
5, 213.138, 0, 0, 0.498059,-99) , 
5, 249.397, 0, 0, 0.505862,-99)    );
  // itree = 89
  fBoostWeights.push_back(0.00706628);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.675207,-99) , 
NN(
NN(
0, 
0, 
-1, 1.42704, 0, 1, 0.5684,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.502094,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.446831,-99) , 
6, -1.52657, 0, 0, 0.498077,-99) , 
5, 201.335, 0, 0, 0.502842,-99) , 
5, 258.085, 0, 0, 0.510784,-99)    );
  // itree = 90
  fBoostWeights.push_back(0.01124);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.671487,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.515218,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.437567,-99) , 
6, 1.52695, 1, 0, 0.509211,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.530449,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.475421,-99) , 
6, 1.52707, 0, 0, 0.47961,-99) , 
7, 0.856783, 0, 0, 0.498353,-99) , 
5, 258.085, 0, 0, 0.506347,-99)    );
  // itree = 91
  fBoostWeights.push_back(0.0114515);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.706276,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.473167,-99) , 
7, 1.14241, 0, 0, 0.623322,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.52161,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.487673,-99) , 
2, 320.118, 0, 0, 0.502723,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.50711,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.389718,-99) , 
0, 2.2848, 1, 0, 0.443554,-99) , 
6, 1.52691, 1, 0, 0.498312,-99) , 
5, 228.492, 0, 0, 0.507174,-99)    );
  // itree = 92
  fBoostWeights.push_back(0.00898615);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.661681,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.604901,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.485102,-99) , 
7, 1.14228, 0, 0, 0.559944,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.505186,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.469421,-99) , 
6, -1.09092, 0, 0, 0.499669,-99) , 
5, 182.416, 0, 0, 0.50641,-99) , 
5, 258.085, 0, 0, 0.513244,-99)    );
  // itree = 93
  fBoostWeights.push_back(0.010747);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.694268,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.491872,-99) , 
7, 1.14241, 0, 0, 0.616537,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.513483,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.46858,-99) , 
6, 1.09088, 1, 0, 0.506612,-99) , 
NN(
0, 
0, 
-1, 0.856771, 0, -1, 0.468916,-99) , 
4, 161.97, 0, 0, 0.498315,-99) , 
5, 228.121, 0, 0, 0.506721,-99)    );
  // itree = 94
  fBoostWeights.push_back(0.00708264);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.657302,-99) , 
NN(
NN(
0, 
0, 
-1, 2.57034, 0, 1, 0.563699,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.502974,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.467682,-99) , 
5, 63.7595, 0, 0, 0.497507,-99) , 
5, 201.333, 0, 0, 0.502019,-99) , 
5, 258.086, 0, 0, 0.508774,-99)    );
  // itree = 95
  fBoostWeights.push_back(0.011304);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.657977,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.586128,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.448069,-99) , 
7, 0.856833, 0, 0, 0.548976,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.506692,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.477256,-99) , 
2, 306.52, 0, 0, 0.491003,-99) , 
5, 182.417, 0, 0, 0.497491,-99) , 
5, 258.085, 0, 0, 0.504675,-99)    );
  // itree = 96
  fBoostWeights.push_back(0.00902532);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 1.14217, 0, 1, 0.637629,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.55635,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.54535,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.491139,-99) , 
4, 340.629, 0, 0, 0.494765,-99) , 
5, 196.033, 0, 0, 0.497976,-99) , 
5, 228.492, 0, 0, 0.507998,-99)    );
  // itree = 97
  fBoostWeights.push_back(0.00877204);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.632103,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.509463,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.424343,-99) , 
6, 1.76518, 1, 0, 0.504958,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.500597,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.447421,-99) , 
2, 447.684, 0, 0, 0.460223,-99) , 
6, -1.09085, 0, 0, 0.49807,-99) , 
5, 258.088, 0, 0, 0.503641,-99)    );
  // itree = 98
  fBoostWeights.push_back(0.0101771);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 1.14234, 0, 1, 0.637452,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.508453,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.477818,-99) , 
7, 0.856572, 0, 0, 0.497222,-99) , 
NN(
0, 
0, 
-1, 1.14161, 1, -1, 0.442924,-99) , 
6, 1.52717, 1, 0, 0.493257,-99) , 
5, 228.121, 0, 0, 0.503706,-99)    );
  // itree = 99
  fBoostWeights.push_back(0.0064536);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.636775,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.594787,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.48252,-99) , 
7, 1.14116, 0, 0, 0.553546,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.500498,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.467244,-99) , 
6, -1.0909, 0, 0, 0.495418,-99) , 
5, 195.005, 0, 0, 0.499694,-99) , 
5, 249.397, 0, 0, 0.506413,-99)    );
   return;
};
 
// Clean up
inline void ReadBDT_100_25_01_10::Clear() 
{
   for (unsigned int itree=0; itree<fForest.size(); itree++) { 
      delete fForest[itree]; 
   }
}
   inline double ReadBDT_100_25_01_10::GetMvaValue( const std::vector<double>& inputValues ) const
   {
      // classifier response value
      double retval = 0;

      // classifier response, sanity check first
      if (!IsStatusClean()) {
         std::cout << "Problem in class \"" << fClassName << "\": cannot return classifier response"
                   << " because status is dirty" << std::endl;
         retval = 0;
      }
      else {
         if (IsNormalised()) {
            // normalise variables
            std::vector<double> iV;
            iV.reserve(inputValues.size());
            int ivar = 0;
            for (std::vector<double>::const_iterator varIt = inputValues.begin();
                 varIt != inputValues.end(); varIt++, ivar++) {
               iV.push_back(NormVariable( *varIt, fVmin[ivar], fVmax[ivar] ));
            }
            retval = GetMvaValue__( iV );
         }
         else {
            retval = GetMvaValue__( inputValues );
         }
      }

      return retval;
   }
